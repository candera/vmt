(ns weathergen.ui.common
  "Things used across various UI libraries."
  (:require [cljsjs.tinycolor]
            [clojure.pprint :as pp]
            [garden.core :refer [css]]
            [goog.string :as gstring]
            [goog.string.format]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)]
            [weathergen.falcon.files.mission :as mission])
  (:require-macros
   [weathergen.cljs.macros :refer [with-bbox with-time formula-of formula-of$]]))

;; This is a massive hack, and I have no idea what we're going to do if some other library decides to
;; say `module.exports` in its code.
(def tinycolor (.-exports js/module)
  #_(if (= "nodejs" cljs.core/*target*)
    (.-exports js/module)
    js/tinycolor))

(def colors
  {:invalid       "#c70505"
   :invalid-background "#fcc"
   :error-message "#c70505"
   :edit "rgba(128,128,255,0.5)"
   :header-background "lightgray"
   :team {:dark-text {:white "gray"
                      :green "green"
                      :blue "blue"
                      :brown "#923c25"
                      :orange "darkorange"
                      :yellow "#caae18"
                      :red "red"
                      :gray "darkgray"}
          :light-text {:white "white"
                       :green "lightgreen"
                       :blue "#8ddbf5"
                       :brown "#e27e43"
                       :orange "orange"
                       :yellow "yellow"
                       :red "#f9adad"
                       :gray "lightgray"}}})

(defn team-color
  "Returns a color for a team."
  [team type]
  (get-in colors [:team type (mission/team-color team)]))

(def registered-styles (atom #{}))

(defn register-styles!
  "Adds styles to the head of the document. If already registered under `key`, does nothing."
  [key garden]
  (when-not (contains? @registered-styles key)
    (let [head (aget (.getElementsByTagName js/document "head") 0)
          styles (cell= (css garden))]
      (.appendChild head (style :type "text/css" styles))
      (swap! registered-styles conj key))))

(defn contrasting
  "Returns a color that contrasts well with the specified color.
  Optionally, the colors to use for dark and light can be specified."
  ([color] (contrasting color "black" "white"))
  ([color dark light]
   ;; http://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
   (-> tinycolor (.mostReadable color #js [dark light]) .toHexString)
   #_(let [rgb (-> color tinycolor .toRgb)
         ;; Advanced compilation is somehow screwing up direct field
         ;; access, so we have to go in by name.
         r (aget rgb "r")
         g (aget rgb "g")
         b (aget rgb "b")]
     (if (< 128 (+ (* r 0.299) (* g 0.587) (* b 0.114)))
       dark
       light))))

(defn darken
  "Darkens a color by an amount from 0-100."
  [color amount]
  (-> color tinycolor (.darken amount) .toHexString))

(defn lighten
  "Lightens a color by an amount from 0-100."
  [color amount]
  (-> color tinycolor (.lighten amount) .toHexString))

(defn spin
  "Rotates a color by an amount from 0 to 360 degrees."
  [color amount]
  (-> color tinycolor (.spin amount) .toHexString))

(defn to-hex-str
  "Converts a color to a hex string."
  [color]
  (-> color tinycolor .toHexString))

(defelem styled
  "Creates an element which is a scope for a set of CSS rules,
  provided via a `:garden` attribute, by adding an element with a
  unique ID and new <style> element to the <head> of the document."
  [attrs content]
  (let [{:keys [garden]} attrs
        attrs (dissoc attrs :garden)
        head (aget (.getElementsByTagName js/document "head") 0)
        id (str (gensym))
        styles (cell= (css [(keyword (str "#" id))
                            garden]))]
    (.appendChild head (style :type "text/css" styles))
    (div
     (merge attrs {:id id})
     content)))

(defelem inl
  [attrs content]
  (let [{:keys [css]} attrs]
    (div
     (update attrs
             :css
             (fn [css-orig]
               (if (cell? css-orig)
                 (formula-of [css-orig]
                   (assoc css-orig :display "inline-block"))
                 (assoc css-orig :display "inline-block"))))
     content)))

(defelem triangle
  [attrs _]
  (let [{:keys [r]} attrs
        r*          (cell= r)
        attrs       (dissoc attrs :r)
        alpha       0.8660254037844387 ; sin 60deg
        beta        0.5                ; sin 30deg
        x           (cell= (* r* alpha))
        y           (cell= (* r* alpha))]
    (svg/path
     :d (formula-of$ [x y]
          (gstring/format "M%f,%f L%f,%f L%f,%f Z"
                          0 (- $y)
                          $x $y
                          (- $x) $y))
     attrs)))

(defn pre-cell
  "Pretty-prints the value of cell c and displays it in a pre tag."
  [title c]
  (register-styles!
   ::pre-cell
   [[:.pre-cell {:background "black"
                 :color "green"
                 :font-family "monospace"}]])
  (div
   :class "pre-cell"
   (h4 title)
   (pre
    :css {:white-space "pre-wrap"}
    (cell= (pp/write c :stream nil :pretty true)))))

(defelem control-section
  [attributes children]
  (let [visible (cell (not (:collapsed? attributes)))
        change-visibility #(swap! visible not)]
    (fieldset
     :class "controls"
     (dissoc attributes :title :collapsed? :help-for)
     (legend
      (div
       :click change-visibility
       :class (formula-of [visible]
                          {:toggle true
                           :visible visible})
       "")
      (span
       (:title attributes)))
     (div
      :class "control-visibility-container"
      :toggle visible
      :fade-toggle visible
      (div :class "control-container" children)))))


(defn format-time
  [{:keys [day hour minute]}]
  (gstring/format "%02d/%02d%02d"
                  day
                  hour
                  minute))

(defn image-button-style
  [pressed?]
  {:border-style (if pressed? "inset" "outset")
   :border-color "#ddd"
   :border-radius "6px"
   :padding "2px"
   ;; :width "16px"
   ;; :height "16px"
   :background (if pressed? "lightgrey" "white")
   :border-width "2px"
   :vertical-align "middle"})

(defelem image-button
  [attrs]
  (let [down (cell false)
        css (:css attrs)
        attrs (dissoc attrs :css)]
    (img
     :css (formula-of
            [down]
            (merge (image-button-style down)
                   css))
     :mousedown (fn [e]
                  (let [up (fn up-fn [e]
                             (.removeEventListener js/document "mouseup" up-fn)
                             (reset! down false))]
                    (.addEventListener js/document "mouseup" up))
                  (reset! down true))
     ;; Overriding dragstart stops the browser from trying
     ;; to drag and drop SVG as images, which would
     ;; interfere with our functionality.
     :dragstart (constantly false)
     attrs)))

(defelem color-picker
  [attrs _]
  ;; Because sometimes we want to set the value and not have the
  ;; corresponding change event fire, we override it, and only pass it
  ;; along when the change occurs while the picker is open. If we need
  ;; to, we can add an option or another event for changes that happen
  ;; due to the value cell being updated.
  (let [{:keys [change hide show]} attrs
        attrs* (dissoc attrs :change :hide :show)
        open? (atom false)]
    (with-let [i (input attrs*
                        :class "minicolors"
                        :type "hidden"
                        :change (fn [e]
                                  (when (and change @open?)
                                    (change e))))]
      (add-watch (:value attrs)
                 (-> (gensym) str keyword)
                 (fn [_ _ _ n]
                   (-> i js/jQuery (.minicolors "value" (to-hex-str n)))))
      (when-dom i
        #(-> i js/jQuery (.minicolors #js {"theme" "weathergen"
                                           "show" (fn []
                                                    (reset! open? true)
                                                    (when show (show)))
                                           "hide" (fn []
                                                    (reset! open? false)
                                                    (when hide (hide)))}))))))



