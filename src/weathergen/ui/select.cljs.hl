(ns weathergen.ui.select
  "Homegrown select controls."
  (:require [clojure.string :as str]
            [garden.core :refer [css]]
            [garden.selectors :as css-sel]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)]
            [weathergen.help :as help]
            [weathergen.ui.buttons :as buttons]
            [weathergen.ui.common :as comm :refer [inl pct pre-cell px register-styles! rinl triangle]])
  (:require-macros
   [weathergen.cljs.macros :refer [with-time formula-of with-attr-bindings keyed-for-tpl]]))

(comm/register-class!
 ::hidden
 [{:display "none"}])

#_(comm/register-class!
 ::highlighted
 [{:background "#5897fb"
   :color      "white"}])

(defelem select3
  "Like select2, but artisinal and bespoke.

:data - A cell containing a seq of values.
:value - A cell. The currently selected value, or `nil` if no selection.
:key-fn - Function of choice value returning immutable unique ID.
:search-fn - Function from value to text it should match when searching.
:formatter - Function from cell of value to UI for that item.
:highlight - Function called with highlighted value when value changes.
:max-dropdown-height - (Optional) Max height of dropdown"
  [attrs _]
  (with-attr-bindings attrs [data width value key-fn search-fn formatter highlight max-dropdown-height placeholder]
    (assert search-fn "search-fn is required")
    (assert key-fn "key-fn is required")
    (assert formatter "formatter is required")
    (let [highlighted   (cell nil)
          search-text   (cell nil)
          open?         (cell false)
          border-radius 4
          filtered-data (formula-of [open? data search-text]
                          (cond
                            (not open?)
                            nil

                            (str/blank? search-text)
                            data

                            :else
                            (->> data
                                 (filter #(str/index-of (str/lower-case (search-fn %))
                                                        (str/lower-case search-text))))))
          ;; A map from index to items
          matching-items (formula-of [filtered-data]
                           {:index-to-item (zipmap (range) filtered-data)
                            :key-to-index  (zipmap (map key-fn filtered-data) (range))})
          ids            (formula-of [data]
                           (zipmap (map key-fn data)
                                   (repeatedly #(str (gensym)))))]
      (add-watch highlighted
                 (keyword (gensym))
                 (fn [_ _ _ n]
                   (when highlight
                     (highlight (get-in @matching-items [:index-to-item n])))))
      (do-watch open?
        (fn [_ n]
          (when-not n
            (reset! search-text nil)
            (reset! highlighted nil))))
      (do-watch filtered-data
        (fn [_ n]
          (reset! highlighted 0)))
      (with-let [elem (div)]
        ;; Handling Blur isn't a good solution because clicking on one
        ;; of the list elements also causes a blur, and it happens
        ;; before the click, which screws up our ability to handle the
        ;; click.
        (.addEventListener js/document
                           "click"
                           (fn [e]
                             (when (and @open?
                                        (not (.contains elem (.-target e))))
                               (reset! open? false))))
        (elem
         attrs
         :css
         {:width       width
          :font-family "Open Sans Condensed"
          :position    "relative"}
         (div
          :debug "top row"
          :click #(swap! open? not)
          :css {:cursor "pointer"}
          (div
           :css
           (formula-of [open?]
             {:border-color               "#aaa"
              :border-width               (px 1)
              :border-style               "solid"
              :border-top-left-radius     (px border-radius)
              :border-top-right-radius    (px border-radius)
              :border-bottom-left-radius  (px (if open? 0 border-radius))
              :border-bottom-right-radius (px (if open? 0 border-radius))
              :background                 "white"
              :padding                    (px 3 25 3 5)})
           (formula-of [value]
             (if value
               (formatter value)
               (div
                :css {:color "#999"}
                placeholder))))
          (let [arrow-size 6]
            (div
             :debug "arrow container"
             :css {:display  "inline-block"
                   ;; :padding (px 0 5)
                   :position "absolute"
                   :right    (px 7)
                   :top      (px (/ arrow-size 2))}
             (div
              :css (formula-of [open?]
                     {:display            "inline-block"
                      :width              0
                      :height             0
                      :border-left-width  (px (* 0.66 arrow-size))
                      :border-left-style  "solid"
                      :border-left-color  "transparent"
                      :border-right-width (px (* 0.66 arrow-size))
                      :border-right-style "solid"
                      :border-right-color "transparent"
                      :border-top-width   (px arrow-size)
                      :border-top-style   "solid"
                      :border-top-color   "#888"
                      :transform          (str "rotate("
                                               (if open? 180 0)
                                               "deg)")})))))
         (div
          :debug "dropdown area"
          :css
          (formula-of [open?]
            {:display                    (if open? "block" "none")
             :top                        0
             :position                   "absoute"
             :background                 "white"
             ;; :padding                    (px 0 5)
             :border-color               "#aaa"
             :border-width               (px 1)
             :border-style               "solid"
             :border-top-style           "none"
             :border-bottom-left-radius  (px border-radius)
             :border-bottom-right-radius (px border-radius)})
          ;; Something like this: http://jsfiddle.net/v7YTT/90/
          (let [gap 5]
            (div
             :debug "Search box"
             :css
             {:padding (px 0 gap 2 (* 2 gap))}
             (with-let [i (input
                           :css {:width    (pct 100)
                                 :position "relative"
                                 :right    (px gap)}
                           :value search-text
                           :input #(reset! search-text @%)
                           :keydown (fn [^KeyboardEvent e]
                                      (condp = (.-keyCode e)
                                        comm/ESCAPE_KEY
                                        (reset! open? false)

                                        comm/ENTER_KEY
                                        (when-not (empty? @filtered-data)
                                          (dosync
                                           (reset! open? false)
                                           (reset! value (get-in @matching-items [:index-to-item @highlighted]))))

                                        comm/DOWN_ARROW
                                        (swap! highlighted
                                               #(min (inc %)
                                                     (dec (count @filtered-data))))
                                        #_ (let [next (->> (map vector @filtered-data (drop 1 @filtered-data))
                                                           (filter (fn [[item next-item]]
                                                                     (= item @highlighted)))
                                                           first
                                                           second)]
                                             (when next
                                               (reset! highlighted next)))

                                        comm/UP_ARROW
                                        (swap! highlighted
                                               #(max 0 (dec %)))
                                        #_ (let [prev (->> (map vector @filtered-data (drop 1 @filtered-data))
                                                           (filter (fn [[prev-item item]]
                                                                     (= item @highlighted)))
                                                           first
                                                           first)]
                                             (when prev
                                               (reset! highlighted prev)))

                                        nil)))]
               (do-watch open?
                 (fn [_ n]
                   (when n
                     (with-timeout 0
                       (.focus i))))))))
          (let [has-matches? (cell= (not (empty? filtered-data)))]
            (comm/styled
             :garden (formula-of [highlighted matching-items ids]
                       [(css-sel/selector (str "#" (get ids (key-fn (get-in matching-items [:index-to-item highlighted])))))
                        {:background "#5897fb"
                         :color      "white"}])
             (div :css {:padding-left (px 5)
                        :user-select  "none"}
                  :toggle (cell= (not has-matches?))
                  "No results found")
             (with-let [elem (ul)]
               (do-watch filtered-data
                 (fn [_ _]
                   (-> elem .-scrollTop (set! 0))))
               (elem
                :toggle has-matches?
                :debug "item list area"
                :css {:overflow-y  "scroll"
                      :max-height  (or max-dropdown-height (px 150))
                      :padding     0
                      :margin      0
                      :user-select "none"
                      :list-style "none"}
                (keyed-for-tpl key-fn [item data]
                  (with-let [elem (li)]
                    (do-watch highlighted
                      (fn [_ n]
                        (when (= @item (get-in @matching-items [:index-to-item n]))
                          ;; with-timeout 0
                          (.scrollIntoViewIfNeeded elem))))
                    (elem
                     :id (-> item key-fn ids cell=)
                     :mouseenter #(reset! highlighted (get-in @matching-items [:key-to-index (key-fn @item)]))
                     ;; :mouseleave #(reset! highlighted nil)
                     :class (formula-of [item matching-items #_highlighted]
                              {(comm/class-for ::hidden)
                               (not (contains? (:key-to-index matching-items)
                                               (key-fn item)))
                               #_(comm/class-for ::highlighted)
                               #_(= highlighted (get-in matching-items
                                                          [:key-to-index (key-fn item)]))})
                     #_:css #_(formula-of [item matching-items highlighted]
                            (merge
                             {:display    (if (contains? (:key-to-index matching-items)
                                                         (key-fn item))
                                            "block"
                                            "none")
                              :list-style "none"
                              :padding    0
                              :margin     0}
                             (if (= highlighted (get-in matching-items
                                                        [:key-to-index (key-fn item)]))
                               {:background "#5897fb"
                                :color      "white"}
                               {:background "inherit"
                                :color      "inherit"})))
                     (div
                      :css {:padding-left (px 5)}
                      :click #(dosync
                               (reset! value @item)
                               (reset! open? false))
                      (formatter item))))))))))
         #_(div
            (pre-cell "open?" open?)
            (pre-cell "search-text" search-text)
            (pre-cell "highlighted" highlighted)
            (pre-cell "index-to-item" (cell= (:index-to-item matching-items)))
            (pre-cell "key-to-index" (cell= (:key-to-index matching-items)))))))))
