(ns weathergen.ui.grids
  "Homegrown grid controls."
  (:require [garden.core :refer [css]]
            [garden.selectors :as css-sel]
            [hoplon.svg :as svg]
            [weathergen.ui.common :as comm :refer [inl register-styles! triangle]])
  (:require-macros
   [weathergen.cljs.macros :refer [with-time formula-of]]))

(defelem master-detail
  "Creates a master-detail grid view. TODO: explain options."
  [attrs _]
  (let [{:keys [data detail columns formatter options]} attrs]
    (div
     (dissoc attrs :data :detail :columns :formatter :options)
     (let [data* (cell= data)
           columns* (cell= columns)
           options* (cell= options)
           ;; TODO: Should detail be permitted to be a cell?
           td* (fn [& args]
                 (apply td :css {:border "solid 1px #eee"
                                 :padding "0 2px 0 2px"} args))]
       (table
        :css {:background "white"
              :border-collapse "collapse"
              :outline "solid 1px #ccc"}
        (thead
         (tr
          :css {:background "linear-gradient(to bottom, white, white 33%, #eee 66%)"}
          (formula-of [columns*]
            (for [column columns*]
              (td (:name column))))
          #_(for-tpl [column columns*]
              (td (-> column :name cell=)))))
        (formula-of [data* columns*]
          (for [item data*]
            (let [expanded? (cell true)
                  subitems (detail item)
                  spacer-width "12px"
                  spacer-margin "3px"
                  spacing {:width spacer-width
                           :margin-right spacer-margin
                           :display "inline-block"}
                  spacer (fn [] (span :css spacing))]
              [(tbody
                (tr
                 (td*
                  :colspan (count columns*)
                  (if (-> subitems count zero?)
                    (spacer)
                    (div :css {:width spacer-width
                               :margin-right spacer-margin
                               :display "inline-block"
                               :text-align "center"
                               :vertical-align "middle"
                               :height "12px"
                               :border-radius "50%"
                               :border-color "black"
                               :border-style "solid"
                               :border-width "1px"
                               :text-anchor "6px"
                               :font-size "120%"
                               :line-height "12px"
                               :font-weight "bold"}
                         :click #(swap! expanded? not)
                         (if-tpl expanded? "-" "+")))
                  (formatter item))))
               (tbody
                (for [subitem subitems]
                  (tr
                   :fade-toggle expanded?
                   (let [formatter (:formatter (first columns*))]
                     (td*
                      (spacer)
                      (spacer)
                      (formatter subitem)))
                   (for [column (drop 1 columns*)]
                     (td*
                      (let [formatter (:formatter column)]
                        (formatter subitem)))))))])))
        #_(for-tpl [item data*]
            (let [expanded? (cell true)
                  subitems (formula-of [item] (detail item))]
              [(tbody
                (tr
                 (for-tpl [column columns*]
                   [(if-tpl (-> subitems count zero? cell=)
                      ""
                      (button :click #(swap! expanded? not) (if-tpl expanded? "-" "+")))
                    (cell=
                     (td* (formula-of [column item]
                            (let [fmt (:formatter column)]
                              (fmt :master item)))))])))
               (tbody
                :fade-toggle expanded?
                (for-tpl [subitem subitems]
                  (tr
                   (for-tpl [column columns*]
                     (td* (formula-of [column subitem]
                            (let [fmt (:formatter column)]
                              (fmt :detail subitem))))))))])))))))

(defn- sorters
  "Returns UI for the sort handles at the top of a column.
  `sort-state` is a tuple of column index and direction for the
  current sort. `column-index` is the index of the column we're
  rendering."
  [sort-criteria column-index]
  (inl
   :class "sorters"
   (svg/svg
    :width "20px"
    :viewBox "-100 -100 200 200"
    (comm/triangle :transform "rotate(180) translate(0 -50)"
                   :r 50
                   :stroke "black"
                   :stroke-width "2"
                   :fill (cell= (if (= sort-criteria [column-index :ascending])
                                  "black"
                                  "none")))
    (comm/triangle :transform "translate(0 -50)"
                   :r 50
                   :stroke "black"
                   :stroke-width "2"
                   :fill (cell= (if (= sort-criteria [column-index :descending])
                                  "black"
                                  "none"))))))

;; :data - A cell containing a seq of maps
;; :row-attrs - A function from a cell containing a row to an Hoplon
;;              attrs map
;; :columns - A seq of maps describing columns
;;
;; Column description:
;; :title - Shows up in the header row
;; :sort-key - Function from a row value (not cell) to a sort value
;; :formatter - Function from a row cell to UI
(defelem table-grid
  [attrs _]
  (register-styles!
   ::table-grid
   [[:table.table-grid {:border-collapse "collapse"}
     [(css-sel/tr (css-sel/nth-child :even))
      {:background "#eee"}]
     [(css-sel/tr (css-sel/nth-child :odd))
      {:background "white"}]
     [:thead
      [:td {:background "#ddd"
            :border "solid 1px grey"
            :padding "2px 4px 4px 4px"}]
      [:.sorters {:float "right"}
       [:svg {:vertical-align "bottom"}]]]
     [:tbody [:td {:padding "2px 3px 2px 3px"
                   :border "solid 1px lightgray"
                   :border-bottom "none"
                   :border-top "none"}]]]])
  (let [{:keys [data columns row-attrs]} attrs
        attrs (dissoc attrs :data :columns :row-attrs)
        sort-criteria (cell nil)
        sorted-items (formula-of [data sort-criteria]
                       (if-not sort-criteria
                         data
                         (let [[sort-column sort-direction] sort-criteria
                               {:keys [sort-key formatter]} (nth columns sort-column)]
                           (sort-by sort-key
                                    (if (= sort-direction :ascending)
                                      compare
                                      (fn [a b]
                                        (- (compare a b))))
                                    data))))]
    (table
     :class "table-grid"
     (thead
      (tr (for [[column-index {:keys [title disable-sort]}] (map-indexed vector columns)]
            (td
             :click #(when-not disable-sort
                       (swap! sort-criteria
                              (fn [[old-index direction]]
                                [column-index
                                 (cond
                                   (not= old-index column-index)
                                   :ascending

                                   (= direction :ascending)
                                   :descending

                                   :else
                                   :ascending)]))
                       false)
             title
             (if disable-sort
               []
               (sorters sort-criteria column-index))))))
     (tbody
      (for-tpl [item sorted-items]
        (tr
         (row-attrs item)
         (for [{:keys [formatter]} columns]
           (td (formatter item)))))))))
