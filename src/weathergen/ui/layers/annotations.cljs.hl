(ns weathergen.ui.layers.annotations
  "Responsible for drawing the map annotations and the associated
  controls. Annotations are informational overlays added to the map:
  squares, ovals, text, lines, etc."
  (:require [clojure.pprint :refer [pprint]]
            [clojure.string :as str]
            [goog.string :as gstring]
            [goog.string.format]
            [hoplon.svg :as svg]
            [weathergen.help :as help :refer [with-help]]
            [weathergen.math :as math]
            [weathergen.ui.buttons :as buttons]
            [weathergen.ui.common :as comm :refer [colors control-section
                                                   dropdown
                                                   ems
                                                   get-image
                                                   format-time inl
                                                   map-lens
                                                   path-lens pct pre-cell px
                                                   styled team-color triangle
                                                   validating-edit]]
            [weathergen.ui.tabs :as tabs])
  (:require-macros
   [weathergen.cljs.macros :refer [hint->
                                   hint->>
                                   keyed-for-tpl
                                   with-attr-bindings
                                   with-bbox
                                   with-default-lenses
                                   with-key-lenses
                                   with-time]]))

(comm/register-class!
 ::no-focus-border
 [:&:hover {:outline "none"}])

;;; Utilities

(let [counter (atom 0)]
  (defn- unique-id
    []
    (swap! counter inc)))

(defn- point-names
  "Given a cell of points (a map from IDs to 2-tuples), return a cell of
  maps from IDs to names for them."
  [points]
  (formula-of [points]
    (zipmap (sort (keys points))
            (map #(js/String.fromCharCode (+ 65 %))
                 (range)))))

(defn- annotation-rotation
  "Computes the rotation of an arrow (0 is east) given a vector from its
  start to its end."
  [v]
  (-> (- 90 (math/heading v))
      (mod 360)))

(defn- midpoint
  "Returns the vector midpoint of two  "
  [a b]
  (->> a
       (math/vector-add b)
       (math/vector-scale 0.5)))


;;; Overlay

(def font-scale-factor
  7.87406581267874E-4)

;; TODO: Convert these to use linear->exp and exp->linear, below
(let [base 1.0875853314770578
      factor font-scale-factor]
  (defn- font-size->scale
    [font-size]
    (-> (Math/pow base font-size)
        (* factor)))

  (defn- scale->font-size
    [scale]
    (-> scale
        (/ factor)
        Math/log
        (/ (Math/log base)))))

(defn- linear->exp
  "Converts `val`, a value on the linear interval `linear-min` to
  `linear-max`, exponentially along the interval `exp-min` to
  `exp-max`."
  [val linear-min linear-max exp-min exp-max]
  (let [a (/ exp-max exp-min)
        b (Math/pow a (/ 1.0 (- linear-max linear-min)))
        c (/ exp-min (Math/pow b linear-min))]
    (* c (Math/pow b val))))

(defn- exp->linear
  "Complement of `linear->exp`."
  [val linear-min linear-max exp-min exp-max]
  (let [a (/ exp-max exp-min)
        b (Math/pow a (/ 1.0 (- linear-max linear-min)))
        c (/ exp-min (Math/pow b linear-min))]
    (/ (Math/log (/ val c))
       (Math/log b))))

(defn- stroke-and-fill-attrs
  [annotation]
  (with-key-lenses annotation
    [fill-color
     filled?
     border-color
     border-dash-length
     border-dash-spacing
     border-style
     border-width]
    (with-default-lenses
      {border-dash-length  0
       border-dash-spacing 0
       border-width        0}
      (let [bw (formula-of [border-style border-width]
                 (if (= :none border-style)
                   0
                   (/ border-width 200)))]
        {:stroke           (cell= (comm/to-rgba border-color))
         :stroke-width     bw
         :fill             (cell= (if filled?
                                    (comm/to-rgba fill-color)
                                    "none"))
         :stroke-dasharray (formula-of [border-style border-dash-length border-dash-spacing]
                             (when (= border-style :dashed)
                               (let [dash-length (linear->exp border-dash-length
                                                              1 100
                                                              0.005 10)
                                     gap-length  (* dash-length (linear->exp border-dash-spacing
                                                                             1 100
                                                                             0.01 100))]
                                 (str dash-length
                                      " "
                                      gap-length))))}))))

(defn- shape-contents-overlay
  "Returns SVG for the contents of the annotation"
  [{:keys [suppress-bullseye-info-box? dragging]} annotation]
  (with-key-lenses annotation
    [border-color border-width border-style border-dash-length border-dash-spacing
     editing?
     font-bold? font-color font-italic? font-family font-size
     halign
     height
     text
     type
     valign
     width]
    (with-default-lenses
      {border-width        0
       border-dash-length  0
       border-dash-spacing 0
       width               0
       height              0}
      (let [bw     (formula-of [border-style border-width]
                     (if (= :none border-style)
                       0
                       (/ border-width 200)))
            offset (cell= (/ bw 2))
            w      (cell= (max 0 (- width bw)))
            h      (cell= (max 0 (- height bw)))]
        (svg/g
         (stroke-and-fill-attrs annotation)
         (case-tpl type
           :oval (svg/ellipse
                  :x offset
                  :y offset
                  :cx (cell= (/ w 2))
                  :cy (cell= (/ h 2))
                  :rx (cell= (/ w 2))
                  :ry (cell= (/ h 2)))
           :rectangle (svg/rect
                       :x offset
                       :y offset
                       :width w
                       :height h))
         (let [editing-text? (cell false)
               scale-factor  (formula-of [font-size]
                               (font-size->scale font-size))]
           (svg/g
            :transform (cell= (comm/svg-scale scale-factor))
            (let [fo-width  (cell= (/ width scale-factor))
                  fo-height (cell= (/ height scale-factor))]
              (with-let [fo (svg/foreignObject
                             :width fo-width
                             :height fo-height)]
                (let [text-y (cell 0)]
                  (fo
                   :y text-y
                   (with-let [elem (div :class (comm/class-for ::no-focus-border))]
                     (do-watch (formula-of [annotation scale-factor fo-height]
                                 {:scale-factor scale-factor
                                  :annotation annotation
                                  :fo-height fo-height})
                               (fn [_ {:keys [scale-factor annotation fo-height]}]
                                 (let [{:keys [height valign]} annotation]
                                   (with-timeout 0
                                     (reset! text-y
                                             (cond
                                               (= valign :bottom)
                                               (- fo-height (.-clientHeight elem))

                                               (= valign :middle)
                                               (/ (- fo-height (.-clientHeight elem)) 2)

                                               :else
                                               0))))))
                     (elem
                      :xmlns "http://www.w3.org/1999/xhtml"
                      :contenteditable (when-tpl editing-text? "true")
                      :click (fn []
                               (reset! editing-text? true)
                               (with-timeout 0
                                 (.focus elem)))
                      :keyup (fn [^KeyboardEvent e]
                               (when (= comm/ESCAPE_KEY (.-keyCode e))
                                 (dosync
                                  (reset! text (-> elem .-innerText))
                                  (reset! editing-text? false))))
                      :mousemove (fn [e]
                                   (reset! suppress-bullseye-info-box? true)
                                   (.preventDefault e)
                                   false)
                      :blur (fn [e]
                              (dosync
                               (reset! text (-> elem .-innerText))
                               (reset! editing-text? false)))
                      :css (formula-of [font-bold? font-family font-italic? font-color font-size
                                        editing? dragging halign]
                             {:white-space    "pre-wrap"
                              :pointer-events (if (and editing? (nil? dragging)) "all" "none")
                              :cursor         (when editing? "text")
                              :font-family    font-family
                              :font-weight    (when font-bold? "bold")
                              :font-style     (when font-italic? "italic")
                              :padding        (ems 0 0.2)
                              :color          (comm/to-rgba font-color)
                              :text-align     halign})
                      text)))))))))))))

(defn- shape-overlay
  "Returns SVG for a rectangle or oval annotation."
  [annotation
   {:keys [annotations map-viewbox map-zoom] :as state}
   {:keys [register-drag delete-annotation] :as handlers}]
  (with-key-lenses annotation
    [type
     font-size
     font-family
     font-color
     text
     x
     y
     width
     height
     rotation
     editing?]
    (with-default-lenses
      {x         0
       y         0
       width     0
       height    0
       rotation  0
       font-size 0}
      (svg/g
       :transform (cell= (comm/svg-translate x y))
       (svg/g
        :transform (cell= (comm/svg-rotate rotation))
        (let [dragging (cell nil)]
          (svg/g
           :debug "shape annotation"
           (shape-contents-overlay
            (assoc state :dragging dragging)
            annotation)
           (svg/g
            :debug "edit controls"
            (when-tpl editing?
              (let [large-border-width (cell= (/ 0.2 map-zoom))
                    small-border-width (cell= (* large-border-width 0.65))
                    outer-width        (cell= (+ width (* 2 large-border-width)))
                    outer-height       (cell= (+ height (* 2 large-border-width)))
                    size               (cell= (/ 1.7 map-zoom))]

                (let [path (formula-of [outer-width large-border-width size]
                             (let [x (- (/ outer-width 2) large-border-width)
                                   y (* size -2.5)]
                               (str "M" x ",0"
                                    " L" x "," y)))]
                  (svg/g
                   (svg/path
                    :stroke "lightblue"
                    :fill "none"
                    :stroke-width large-border-width
                    :d path)
                   (svg/path
                    :stroke "blue"
                    :fill "none"
                    :stroke-width small-border-width
                    :d path)
                   (svg/rect
                    :width (cell= (- outer-width large-border-width))
                    :height (cell= (- outer-height large-border-width))
                    :x (cell= (* large-border-width -0.5))
                    :y (cell= (* large-border-width -0.5))
                    :stroke "lightblue"
                    :fill "none"
                    :stroke-width large-border-width)
                   (svg/rect
                    :width (cell= (- outer-width large-border-width))
                    :height (cell= (- outer-height large-border-width))
                    :x (cell= (* large-border-width -0.5))
                    :y (cell= (* large-border-width -0.5))
                    :stroke "blue"
                    :fill "none"
                    :stroke-width small-border-width)
                   (let [button (fn [{:keys [x y name src drag click]}]
                                  (svg/g
                                   :debug name
                                   :transform (cell= (comm/svg-translate x y))
                                   :mousedown (fn [_]
                                                (when drag
                                                  (register-drag
                                                   (let [drag-fn (drag)]
                                                     (reset! dragging name)
                                                     (fn [dpos final?]
                                                       (drag-fn dpos final?)
                                                       (when final?
                                                         (reset! dragging nil)))))))
                                   :click (fn [_]
                                            (when click (click)))
                                   (svg/rect
                                    :x 0
                                    :y 0
                                    :width size
                                    :height size
                                    :stroke "black"
                                    :fill (formula-of [dragging]
                                            (if (= dragging name)
                                              "lightblue"
                                              "white"))
                                    :stroke-width (cell= (/ 0.1 map-zoom)))
                                   (svg/image
                                    :xlink-href src
                                    :x (cell= (* size 0.1))
                                    :y (cell= (* size 0.1))
                                    :width (cell= (* size 0.8))
                                    :height (cell= (* size 0.8)))))]
                     (svg/g
                      :debug (cell= (str "edit buttons. Dragging: " (pr-str dragging)))
                      (button {:name "Move"
                               :x    (cell= (- (+ size (/ large-border-width 2))))
                               :y    (cell= (- (+ size (/ large-border-width 2))))
                               :src  "images/move.svg"
                               :drag (fn []
                                       (let [x0 (:x @annotation)
                                             y0 (:y @annotation)]
                                         (fn [[dx dy] final?]
                                           (swap! annotation
                                                  assoc
                                                  :x (+ x0 dx)
                                                  :y (+ y0 dy)))))})
                      (button {:name "Rotate"
                               :x    (cell= (+ (/ width 2) (/ size -2)))
                               :y    (cell= (- (+ (* size 3) (/ large-border-width 2))))
                               :src  "images/rotate.svg"
                               :drag (fn []
                                       (let [theta0 @rotation
                                             pivot  (math/rotate (- theta0) [0 (* @size -2.5)])
                                             v      [(- (/ @width 2)) 0]
                                             x0     @x
                                             y0     @y
                                             p0     (math/rotate theta0 v)]
                                         (fn [[dx dy :as dp] final?]
                                           (let [[x1 y1]   (math/vector-add dp pivot)
                                                 theta1    (math/heading [x1 (- y1)])
                                                 p1        (math/rotate theta1 v)
                                                 [dx0 dy0] (math/vector-add p1
                                                                            (math/vector-scale -1 p0))]
                                             (swap! annotation
                                                    assoc
                                                    :rotation (mod theta1 360)
                                                    :x (+ x0 dx0)
                                                    :y (- y0 dy0))))))})


                      (button {:name "Resize Text"
                               :x    (cell= (+ size (/ large-border-width -2)))
                               :y    (cell= (- (+ size (/ large-border-width 2))))
                               :src  "images/text-resize.svg"
                               :drag (fn []
                                       (let [extent (* 0.5 (:width @map-viewbox))
                                             size0  @font-size]
                                         (fn [[dx dy] final?]
                                           (reset! font-size
                                                   (-> dx
                                                       (/ extent)
                                                       (* 100)
                                                       (+ size0)
                                                       (max 1)
                                                       (min 100))))))})
                      (button {:name  "Done"
                               :x     (cell= (- (+ size (/ large-border-width 2))))
                               :y     (cell= (+ height (/ large-border-width 2)))
                               :src   "images/checkmark.png"
                               :click #(reset! editing? false)})
                      (button {:name  "Delete"
                               :x     (cell= (+ size (/ large-border-width -2)))
                               :y     (cell= (+ height (/ large-border-width 2)))
                               :src   "images/trash.png"
                               :click delete-annotation})
                      (button {:name "Resize"
                               :x    (cell= (+ width (/ large-border-width 2)))
                               :y    (cell= (+ height (/ large-border-width 2)))
                               :src  "images/resize.svg"
                               :drag (fn []
                                       (let [w0     @width
                                             h0     @height
                                             theta0 @rotation]
                                         (fn [dpos final?]
                                           (let [[dx' dy'] (math/rotate theta0 dpos)
                                                 w         (+ w0 dx')
                                                 h         (+ h0 dy')]
                                             (swap! annotation
                                                    assoc
                                                    :width (max 0 w)
                                                    :height (max 0 h))))))})))))))))))))))

(defn move-all
  "Returns a drag handler that will move all the points."
  [points]
  (let [points0 @points]
    (fn [[dx dy :as dp] _]
      (swap! points
             #(->> %
                   (map (fn [[k _]]
                          [k (math/vector-add (get points0 k) dp)]))
                   (into (sorted-map)))))))

(defn- linear-edit-buttons
  "Returns SVG for an arrow or lines annotation."
  [annotation
   {:keys [annotations map-viewbox map-zoom dragging rotation add-points?] :as state}
   {:keys [register-drag delete-annotation] :as handlers}]
  (with-key-lenses annotation
    [points editing? filled?]
    (let [ks       (->> points keys cell=)
          k0       (cell= (first ks))
          k1       (cell= (second ks))
          kn       (cell= (last ks))
          p0       (map-lens points k0)
          x0       (map-lens p0 0)
          y0       (map-lens p0 1)
          p1       (map-lens points k1)
          pn       (map-lens points kn)
          n        (cell= (count points))
          rotation (formula-of [p0 p1 pn n filled?]
                     (let [v01 (-> p1
                                   (math/vector-subtract p0)
                                   math/normalize)
                           v0n (-> pn
                                   (math/vector-subtract p0)
                                   math/normalize)]
                       (annotation-rotation (if (and filled? (< 2 n))
                                              (midpoint v01 v0n)
                                              v01))))]
      (svg/g
       :debug "edit controls"
       (when-tpl (cell= (and editing? (pos? (count points))))
         (let [size      (cell= (/ 1.0 map-zoom))
               half-size (cell= (/ size 2))]
           (svg/g
            ;; TODO: Make all of this stuff work so that the boxes' x and y refer to the
            ;; center of the box, not the upper left corner. And rotate them 180 degrees
            ;; when the absolute rotation is greater than 90.
            (let [button (fn [{:keys [x y name label src drag click cursor scale rotation]}]
                           (let [size      (cell= (* size (or scale 1)))
                                 half-size (cell= (/ size 2))]
                             (svg/g
                              :debug name
                              :transform (cell= (comm/svg-xform-combine
                                                 (comm/svg-translate x y)
                                                 (comm/svg-rotate (or rotation 0))))
                              :mousedown (fn [_]
                                           (when drag
                                             (register-drag
                                              (let [drag-fn (drag)]
                                                (reset! dragging name)
                                                (fn [dpos final?]
                                                  (drag-fn dpos final?)
                                                  (when final?
                                                    (reset! dragging nil)))))))
                              :click (fn [_]
                                       (when click (click)))
                              :css {:cursor cursor}
                              (svg/rect
                               :x (cell= (- half-size))
                               :y (cell= (- half-size))
                               :width size
                               :height size
                               :stroke "black"
                               :fill (formula-of [dragging]
                                       (if (= dragging name)
                                         "lightblue"
                                         "white"))
                               :stroke-width (cell= (/ 0.1 map-zoom)))
                              (when label
                                (svg/text
                                 :transform (formula-of [size]
                                              (comm/svg-scale (/ size 17)))
                                 :css {:pointer-events "none"}
                                 :x 0
                                 :y 1.5
                                 :font-family "Helvetica"
                                 :stroke "Black"
                                 :alignment-baseline "middle"
                                 :text-anchor "middle"
                                 :text label))
                              (when src
                                (svg/image
                                 :xlink-href src
                                 :x (cell= (* size -0.4))
                                 :y (cell= (* size -0.4))
                                 :width (cell= (* size 0.8))
                                 :height (cell= (* size 0.8)))))))]
              (let [spacing   (cell= (* 3 size))
                    bar-width (cell= (* size 0.1))]
                (svg/g
                 :debug (cell= (str "edit buttons. Dragging: " (pr-str dragging)))
                 (svg/g
                  :debug "Point adjustment buttons"
                  :transform (formula-of [x0 y0 rotation]
                               (comm/svg-xform-combine
                                (comm/svg-translate x0 y0)
                                (comm/svg-rotate rotation)))
                  (svg/rect
                   :x (cell= (- spacing))
                   :y 0
                   :width spacing
                   :height bar-width
                   :fill "blue"
                   :stroke "lightblue"
                   :stroke-width (cell= (/ bar-width 2)))
                  (svg/rect
                   :x 0
                   :y (cell= (- spacing))
                   :width bar-width
                   :height (cell= (* 2 spacing))
                   :fill "blue"
                   :stroke "lightblue"
                   :stroke-width (cell= (/ bar-width 2))))
                 (let [point-names (point-names points)]
                   (svg/g
                    :debug "Point buttons"
                    (keyed-for-tpl key [[k _] points]
                      (svg/g
                       :transform (formula-of [points k]
                                    (comm/svg-translate (get-in points [k 0])
                                                        (get-in points [k 1])))
                       (button {:name   (cell= (point-names k))
                                :label  (cell= (point-names k))
                                :cursor "move"
                                :x      0
                                :y      0
                                :drag   (fn []
                                          (let [p0 (get-in @annotation [:points @k])]
                                            (fn [[dx dy :as dp] final?]
                                              (swap! annotation
                                                     assoc-in
                                                     [:points @k]
                                                     (math/vector-add p0 dp)))))})))))
                 (when add-points?
                   (let [intermediaries (formula-of [points filled?]
                                          (let [[_ pfirst] (first points)
                                                [_ plast]  (last points)
                                                mids       (mapv (fn [[kprev pprev] [knext pnext]]
                                                                   [(/ (+ kprev knext) 2)
                                                                    (midpoint pprev pnext)])
                                                                 points
                                                                 (drop 1 points))]
                                            (into (sorted-map)
                                                  (if (and filled? (< 2 (count points)))
                                                    (conj mids [nil (midpoint pfirst plast)])
                                                    mids))))]
                     (do-watch intermediaries
                               (fn [_ n]
                                 (swap! annotation assoc :intermediaries n)))
                     (svg/g
                      :debug "Add point buttons"
                      (keyed-for-tpl key [[k _] intermediaries]
                        (svg/g
                         :transform (formula-of [intermediaries k]
                                      (comm/svg-translate (get-in intermediaries [k 0])
                                                          (get-in intermediaries [k 1])))
                         (button {:name   (cell= (str "intermediary" k))
                                  :label  "+"
                                  :cursor "move"
                                  :scale  0.8
                                  :x      0
                                  :y      0
                                  :drag   (fn []
                                            (let [k0 (or @k (unique-id))
                                                  p0 (get @intermediaries @k)]
                                              (fn [[dx dy :as dp] final?]
                                                (swap! annotation
                                                       assoc-in
                                                       [:points k0]
                                                       (math/vector-add p0 dp)))))}))))))
                 (svg/g
                  :debug "Big edit buttons"
                  :transform (formula-of [x0 y0 rotation]
                               (comm/svg-xform-combine
                                (comm/svg-translate x0 y0)
                                (comm/svg-rotate rotation)))
                  (button {:name     "Move"
                           :cursor   "move"
                           :scale    2
                           :x        (cell= (- spacing))
                           :y        0
                           :rotation (cell= (- rotation))
                           :src      "images/move.svg"
                           :drag     (fn []
                                       (move-all points))})
                  (button {:name     "Done"
                           :cursor   "pointer"
                           :scale    2
                           :x        0
                           :y        spacing
                           :rotation (cell= (- rotation))
                           :src      "images/checkmark.png"
                           :click    #(reset! editing? false)})
                  (button {:name     "Delete"
                           :cursor   "pointer"
                           :scale    2
                           :x        0
                           :y        (cell= (- spacing))
                           :rotation (cell= (- rotation))
                           :src      "images/trash.png"
                           :click    delete-annotation}))))))))))))

(defn- arrow-overlay
  "Returns SVG for an arrow annotation."
  [annotation
   {:keys [annotations map-viewbox map-zoom] :as state}
   {:keys [register-drag delete-annotation] :as handlers}]
  (with-key-lenses annotation
    [points arrowhead-width arrowhead-length shaft heft editing?]
    (with-default-lenses
      {arrowhead-width  0
       arrowhead-length 0
       shaft            0}
      (let [dragging (cell nil)
            rotation (formula-of [points]
                       (let [a (get points 0)
                             b (get points 1)]
                         (-> b
                             (math/vector-subtract a)
                             annotation-rotation)))
            length   (formula-of [points]
                       (let [a (get points 0)
                             b (get points 1)]
                         (-> b
                             (math/vector-subtract a)
                             math/magnitude)))]
        (svg/g
         (svg/g
          :debug "Arrow annotation"
          :transform (formula-of [points]
                       (let [a       (get points 0)
                             [ax ay] a]
                         (comm/svg-translate ax ay)))
          :css (formula-of [editing?]
                 {:cursor         (when editing? "move")
                  :pointer-events (when-not editing? "none")})
          (svg/g
           :transform (cell= (comm/svg-rotate rotation))
           (svg/g
            :mousedown (fn [_]
                         (reset! dragging "all")
                         (let [a (get-in @annotation [:points 0])
                               b (get-in @annotation [:points 1])]
                           (register-drag
                            (fn [[dx dy :as dp] final?]
                              (swap! annotation
                                     #(-> %
                                          (assoc-in [:points 0]
                                                    (math/vector-add a dp))
                                          (assoc-in [:points 1]
                                                    (math/vector-add b dp))))
                              (when final?
                                (reset! dragging nil))))))
            (stroke-and-fill-attrs annotation)
            (svg/polygon
             :points (formula-of [arrowhead-width arrowhead-length shaft heft length]
                       (let [heft*           (linear->exp heft 1 100 0.1 10)
                             shaft*          (* heft* (linear->exp shaft 1 100 0.005 4))
                             head-width      (linear->exp arrowhead-width 1 100 0.005 25)
                             head-length     (linear->exp arrowhead-length 1 100 0.005 10)
                             abs-head-width  (* head-width heft*)
                             abs-head-length (* head-length heft*)
                             shaft-end-x     (- length abs-head-length)
                             shaft-top-y     (/ shaft* -2)
                             shaft-bottom-y  (- shaft-top-y )
                             head-top-y      (/ abs-head-width -2)
                             head-bottom-y   (- head-top-y)]
                         (->> [[0 shaft-top-y]
                               [shaft-end-x shaft-top-y]
                               [shaft-end-x head-top-y]
                               [length 0]
                               [shaft-end-x head-bottom-y]
                               [shaft-end-x shaft-bottom-y]
                               [0 shaft-bottom-y]]
                              (map #(str/join "," %))
                              (str/join " "))))))))
         (linear-edit-buttons annotation
                              (assoc state
                                     :dragging dragging)
                              handlers))))))

(defn- lines-overlay
  [annotation
   {:keys [annotations map-viewbox map-zoom] :as state}
   {:keys [register-drag delete-annotation] :as handlers}]
  (with-key-lenses annotation
    [points filled? editing?]
    (let [dragging (cell nil)
          path (formula-of [points]
                 (->> points
                      (sort-by key)
                      (map val)
                      (map (fn [[x y]] (str x "," y)))
                      (str/join " ")))
          attrs (stroke-and-fill-attrs annotation)]
      (svg/g
       :debug "Line annotation"
       :css (formula-of [editing?]
              {:cursor         (when editing? "move")
               :pointer-events (when-not editing? "none")})
       :mousedown (fn [_]
                    (reset! dragging "all")
                    (let [move-all (move-all points)]
                      (register-drag
                       (fn [[dx dy :as dp] final?]
                         (move-all dp final?)
                         (when final?
                           (reset! dragging nil))))))
       (if-tpl filled?
         (svg/polygon attrs :points path)
         (svg/polyline attrs :points path))
       (linear-edit-buttons annotation
                            (assoc state
                                   :dragging dragging
                                   :add-points? true)
                            handlers)))))

(defn- overlay
  "Renders the UI for the display of the annotations."
  [{:keys [annotations] :as state}
   register-drag-handler]
  (svg/g
   :id "annotations-overlay"
   (keyed-for-tpl key [[k _] annotations]
     (let [annotation (comm/map-lens annotations k)
           delete     (fn []
                        (swap! annotations dissoc @k))]
       (with-key-lenses annotation
         [rotation type x y editing? hidden?]
         (with-default-lenses
           {rotation 0
            x        0
            y        0}
           (svg/g
            :css (formula-of [editing? hidden?]
                   {:display (when (and (not editing?) hidden?)
                               "none")})
            (case-tpl (cell= type)
              :rectangle
              (shape-overlay annotation
                             state
                             {:register-drag     register-drag-handler
                              :delete-annotation delete})
              :oval
              (shape-overlay annotation
                             state
                             {:register-drag     register-drag-handler
                              :delete-annotation delete})
              :arrow
              (arrow-overlay annotation
                             state
                             {:register-drag     register-drag-handler
                              :delete-annotation delete})

              :lines
              (lines-overlay annotation
                             state
                             {:register-drag     register-drag-handler
                              :delete-annotation delete})))))))))

;;; Controls

(defn- coord-edit
  "Returns UI for a coordinate edit over `source`."
  [source]
  (validating-edit
   :width 50
   :source source
   :conform comm/conform-nonnegative-float
   :placeholder "0.00"
   :fmt (fn [v] (.toFixed v 2))))

(defn- helped
  "Wraps `contents` in an appropriate `with-help`."
  [help-tag contents]
  (with-help [:map-controls :annotations help-tag]
    contents))

(defn- location-controls
  "Returns UI for the location of an annotation."
  [label help-tag x y & extra-columns]
  (with-default-lenses
    {x 0
     y 0}
    (apply tr
           (td (helped help-tag label))
           (td (coord-edit x))
           (td (coord-edit y))
           extra-columns)))

(defn- shape-location-controls
  "Returns UI for the location of a shape annotation."
  [annotation]
  (with-key-lenses annotation [x y]
    (with-default-lenses
      {x 0
       y 0}
      (location-controls "Location:" :location x y))))

(defn- size-controls
  "Returns UI for the size of an annotation."
  [annotation]
  (with-key-lenses annotation [width height]
    (with-default-lenses
      {width  0
       height 0}
      (tr (td (helped :size "Size:"))
          (td (coord-edit width))
          (td (coord-edit height))))))

(defn- rotation-controls
  "Returns UI for the rotation of an annotation."
  [annotation]
  (with-key-lenses annotation [rotation]
    (with-default-lenses
      {rotation 0}
      (tr (td (helped :rotation "Rotation:"))
          (td (validating-edit
               :width 50
               :source rotation
               :conform (comm/float-conformer -360 360)
               :placeholder "0.00"
               :fmt (fn [v] (.toFixed v 2))))))))

(defn- range-controls
  "Returns UI for a range slider that moves between 1 and 100."
  [label help-tag source]
  (tr (td (helped help-tag label))
      (td (comm/slider
           :css {:width          (pct 100)
                 :vertical-align "middle"}
           :value source
           :min 1
           :max 100))
      (td (validating-edit
           :source source
           :width 50
           :placeholder "0.00"
           :conform (comm/float-conformer 1 100)
           :fmt (fn [v] (.toFixed v 2))))))

(defn- checkbox-controls
  "Returns UI for a boolean option."
  [label help-tag source]
  (tr (td (helped help-tag label))
      (td (comm/checkbox
           :css {:width          (pct 100)
                 :vertical-align "middle"}
           :value source))))

(defn- color-controls
  "Returns UI for a color picker control."
  [label help-tag source]
  (tr (td (helped help-tag label))
      (td (comm/color-picker2
           :value source
           :alpha? true))
      (td (validating-edit
           :width 70
           :source source
           :conform (fn [source*]
                      (formula-of [source*]
                        (let [c      (comm/tinycolor source*)
                              valid? (.isValid c)]
                          {:valid?  valid?
                           :message (when-not valid? "Must be a valid color")
                           :value   source*})))
           :placeholder "#aarrggbb"
           :fmt identity))))

(defn- point-controls
  "Returns UI for the locations of points within a line or arrow."
  [annotation allow-modify? map-viewbox]
  (with-key-lenses annotation [points]
    (let [point-names (point-names points)]
      (div
       (table
        (keyed-for-tpl key [[k _] points]
          (let [point (comm/map-lens points k)
                x     (comm/path-lens point [0])
                y     (comm/path-lens point [1])]
            (location-controls (cell= (str (point-names k) ":"))
                               :points
                               x
                               y
                               (when allow-modify?
                                 (td
                                  (buttons/image-button
                                   :click (fn [_]
                                            (swap! points dissoc @k))
                                   ;; :css {:margin-left (px 10)}
                                   :src "images/trash.png"
                                   :title "Delete Point"
                                   :width (px 16))))))))
       (when allow-modify?
         (buttons/a-button
          :click (fn [_]
                   (swap! annotation
                          update
                          :points
                          assoc
                          (unique-id)
                          (if (empty? @points)
                            (let [{:keys [x y width height]} @map-viewbox]
                              [(+ x (/ width 2))
                               (+ y (/ height 2))])
                            (-> @points
                                vals
                                last
                                (math/vector-add [0 (-> @map-viewbox
                                                        :width
                                                        (/ 20))])
                                (math/vector-clamp [0 0] [59 59])))))
          "Add New Point"))))))

(defn- arrow-appearance-controls
  "Returns UI for the appearance of an arrow."
  [annotation]
  (with-key-lenses annotation [shaft arrowhead-length arrowhead-width heft]
    (with-default-lenses
      {shaft            0
       arrowhead-width  0
       arrowhead-length 0
       heft             0}
      (table
       (range-controls "Overall:" :heft heft)
       (range-controls "Shaft:" :shaft shaft)
       (range-controls "Head Width:" :arrowhead-width arrowhead-width)
       (range-controls "Head Length:" :arrowhead-length arrowhead-length)))))

(defn- text-controls
  "Returns UI for the controls used to render a text annotation."
  [annotation]
  (with-key-lenses annotation
    [font-size font-family font-color font-bold? font-italic?
     halign
     height
     rotation
     text
     valign
     width]
    (with-default-lenses
      {font-size 0}
      (table
       (range-controls "Font Size:" :font-size font-size)
       (tr (td (helped :font "Font:"))
           (td :colspan 2
               (comm/select2
                :css {:width (pct 100)}
                :value font-family
                :choices (for [font ["Arial"
                                     "Bookman"
                                     "Comic Sans MS"
                                     "Courier"
                                     "Courier New"
                                     "Garamond"
                                     "Georgia"
                                     "Helvetica"
                                     "Palatino"
                                     "Times"
                                     "Times New Roman"
                                     "Verdana"]]
                           {:value font
                            :label font})
                :formatter (fn [{:keys [label]}]
                             (span :css {:font-family label}
                                   label)))))
       (tr (td (helped :halign "Horizontal alignment:"))
           (td :colspan 2
               (comm/select2
                :css {:width (pct 100)}
                :value halign
                :choices [{:value "left"
                           :label "Left"}
                          {:value "center"
                           :label "Center"}
                          {:value "right"
                           :label "Right"}])))
       (tr (td (helped :valign "Vertical alignment:"))
           (td :colspan 2
               (comm/select2
                :css {:width (pct 100)}
                :value valign
                :choices [{:value :top
                           :label "Top"}
                          {:value :middle
                           :label "Middle"}
                          {:value :bottom
                           :label "Bottom"}])))
       (tr (td (helped :font-bold? "Bold?:"))
           (td (comm/checkbox :value font-bold?)))
       (tr (td (helped :font-italic? "Italic?:"))
           (td (comm/checkbox :value font-italic?)))
       (color-controls "Color:" :color font-color)
       (tr (td (helped :text "Text:"))
           (td :colspan 2
               (with-let [elem (textarea)]
                 (do-watch text
                           (fn [_ _]
                             (with-timeout 0
                               (-> elem
                                   js/jQuery
                                   (.css #js {:height     "auto"
                                              :overflow-y "hidden"})
                                   (.height (max 20 (.-scrollHeight elem)))))))
                 (elem
                  :css (formula-of [font-family font-italic? font-bold?]
                         {:font-family          font-family
                          :font-style           (when font-italic? "italic")
                          :font-weight          (when font-bold? "bold")
                          :font-size            (pct 100)
                          :width                (pct 100)
                          :horizontal-alignment halign})
                  :value text
                  :placeholder "Enter text here"
                  :input #(reset! text @%)))))))))

(defn- border-controls
  "Returns UI for the controls used to set up borders."
  [annotation]
  (with-key-lenses annotation
    [border-style
     border-width
     border-color
     border-dash-length
     border-dash-spacing]
    (with-default-lenses
      {border-width        0
       border-dash-length  0
       border-dash-spacing 0}
      (table
       (let [dashed?     (cell= (= border-style :dashed))
             has-border? (cell= (#{:dashed :solid} border-style))]
         (tbody
          (tr (td (helped :border-style "Border style:"))
              (td :colspan 2
                  (comm/select2
                   :css {:width (pct 100)}
                   :value border-style
                   :choices [{:value :none
                              :label "No Border"}
                             {:value :solid
                              :label "Solid"}
                             {:value :dashed
                              :label "Dashed"}]
                   :formatter :label)))
          (when-tpl has-border?
            (color-controls "Border color:" :border-color border-color))
          (when-tpl has-border?
            (range-controls "Border width:" :border-width border-width))
          (when-tpl dashed?
            (range-controls "Dash length:" :border-dash-length border-dash-length))
          (when-tpl dashed?
            (range-controls "Dash spacing:" :border-dash-spacing border-dash-spacing))))))))

(defn- controls
  "Returns UI for the map annotation controls."
  [{:keys [annotations map-viewbox map-zoom] :as state}]
  (control-section
   :title (helped :overview "Annotations")
   (div
    (let [make (fn [type overrides]
                 (let [{:keys [x y width height]} @map-viewbox
                       font-size                  (scale->font-size (/ width 59 4))]
                   (swap! annotations
                          assoc
                          (unique-id)
                          (let [defaults {:type                type
                                          :text                "Edit this text"
                                          :font-size           font-size
                                          :font-color          "white"
                                          :font-family         "Times New Roman"
                                          :halign              "center"
                                          :valign              :middle
                                          :fill-color          "#80000000"
                                          :filled?             true
                                          :x                   (+ x (/ width 4))
                                          :y                   (+ y (/ height 2.0))
                                          :width               (/ width 2)
                                          :height              (/ height 12)
                                          :rotation            0
                                          :editing?            true
                                          :hidden?             false
                                          :border-style        :solid
                                          :border-color        "black"
                                          :border-width        (/ 12 @map-zoom)
                                          :border-dash-length  font-size
                                          :border-dash-spacing 50}]
                            (merge defaults (overrides defaults))))))]
      (div
       (buttons/a-button
        :click #(make :rectangle (constantly nil))
        "Add Shape")
       (buttons/a-button
        :click #(make :arrow (fn [{:keys [font-size width x y]}]
                               (let [zoom    @map-zoom
                                     rescale (fn [val lower upper]
                                               (-> val
                                                   (linear->exp 1 100 lower upper)
                                                   (/ zoom)
                                                   (exp->linear 1 100 lower upper)))]
                                 {:shaft            (rescale 70 0.005 4)
                                  :arrowhead-width  (rescale 65 0.005 25)
                                  :arrowhead-length (rescale 82 0.005 10)
                                  :heft             50
                                  :points           (sorted-map 0 [x y]
                                                                1 [(+ x width) y])})))
        "Add Arrow")
       (buttons/a-button
        :click #(make :lines (fn [{:keys [font-size width x y]}]
                               (let [zoom    @map-zoom
                                     rescale (fn [val lower upper]
                                               (-> val
                                                   (linear->exp 1 100 lower upper)
                                                   (/ zoom)
                                                   (exp->linear 1 100 lower upper)))]
                                 {:points (sorted-map 0 [x y]
                                                      1 [(+ x width) y])})))
        "Add Lines")))
    (div
     :css {:display   "flex"
           :flex-wrap "wrap"}
     (keyed-for-tpl key
         [[k _] annotations]
         (let [annotation (map-lens annotations k)]
           (with-key-lenses annotation [type editing? hidden? fill-color filled?]
             (do-watch type
                       (fn [_ n]
                         #_(.log js/console "Type has changed to" (pr-str n)
                                 "border-width" (pr-str (:border-width n)))
                         (cond
                           (#{:rectangle :oval} n)
                           (swap! annotation
                                  #(cond-> %
                                     ))

                           (= :arrow n)
                           (swap! annotation
                                  #(cond-> %)))))
             (div
              :css (formula-of [hidden?]
                     {:border-width  (px 3)
                      :border-style  (if hidden? "dashed" "double")
                      :border-color  "grey"
                      :padding       (px 0 5 30)
                      :margin-bottom (px 3)
                      :margin-right  (px 3)
                      :min-width     (px 350)
                      :min-height    (px 330)
                      :position      "relative"})
              (div
               :css {:margin (px 5 0 15 7)}
               (inl
                {:css {:margin-right (px 10)}}
                (helped :type "Type:"))
               (inl
                (cond-tpl
                  (cell= (#{:rectangle :oval} type))
                  (comm/select2
                   :value type
                   :choices [{:value :rectangle
                              :label "Rectangle"}
                             {:value :oval
                              :label "Oval"}])

                  (cell= (#{:arrow} type))
                  (span {:css {:font-size "110%"}}
                        "Arrow")

                  (cell= (#{:lines} type))
                  (span {:css {:font-size "110%"}}
                        "Lines"))))
              (let [all-tabs   [{:id    :shape-positioning
                                 :title "Positioning"
                                 :ui
                                 (table
                                  (shape-location-controls annotation)
                                  (size-controls annotation)
                                  (rotation-controls annotation))}
                                {:id    :arrow-positioning
                                 :title "Positioning"
                                 :ui    (point-controls annotation false nil)}
                                {:id    :line-positioning
                                 :title "Positioning"
                                 :ui    (point-controls annotation
                                                        true
                                                        map-viewbox)}
                                {:id    :arrow-appearance
                                 :title "Appearance"
                                 :ui    (arrow-appearance-controls annotation)}
                                {:id    :border
                                 :title "Border"
                                 :ui    (border-controls annotation)}
                                {:id    :fill
                                 :title "Fill"
                                 :ui
                                 (comm/styled
                                  :garden [:td {:min-width (px 40)}]
                                  (table
                                   (checkbox-controls "Fill:" :filled? filled?)
                                   (when-tpl filled?
                                     (color-controls "Color:" :fill-color fill-color))))}
                                {:id    :text
                                 :title "Text"
                                 :ui    (text-controls annotation)}
                                {:id    :debug
                                 :title "Debug"
                                 :ui    (pre
                                         :css {:white-space "pre-wrap"}
                                         (cell= (with-out-str (pprint (into (sorted-map) annotation)))))}]
                    shape-tabs #{:shape-positioning :border :fill :text :debug}
                    arrow-tabs #{:arrow-positioning :arrow-appearance :border :fill :debug}
                    line-tabs  #{:line-positioning :border :fill :debug}]
                (cond-tpl
                  (cell= (= :arrow type))
                  (tabs/tabs
                   :selected (cell :arrow-positioning)
                   :tabs (->> all-tabs (filter #(-> % :id arrow-tabs))))

                  (cell= (= :lines type))
                  (tabs/tabs
                   :selected (cell :line-positioning)
                   :tabs (->> all-tabs (filter #(-> % :id line-tabs))))

                  :else
                  (tabs/tabs
                   :selected (cell :shape-positioning)
                   :tabs (->> all-tabs (filter #(-> % :id shape-tabs))))))
              (buttons/image-button
               :css {:position "absolute"
                     :bottom   (px 5)}
               :click #(swap! editing? not)
               :title "Edit"
               :src "images/edit.svg"
               :width "16px"
               :height "16px"
               :latched? editing?)
              (buttons/image-button
               :css {:position "absolute"
                     :bottom   (px 5)
                     :left     (px 32)}
               :click #(swap! hidden? not)
               :title "Hide"
               :src "images/hide-eye.svg"
               :width "16px"
               :height "16px"
               :latched? hidden?)
              (buttons/image-button
               :css {:position "absolute"
                     :bottom   (px 5)
                     :left     (px 59)}
               :click #(swap! annotations
                              assoc
                              (unique-id)
                              @annotation)
               :title "Hide"
               :src "images/copy.svg"
               :width "16px"
               :height "16px")
              (buttons/image-button
               :css {:position "absolute"
                     :bottom   (px 5)
                     :right    (px 5)}
               :src "images/trash.png"
               :width "16px"
               :title "Remove"
               :click #(swap! annotations
                              dissoc
                              @k))))))))))

(defn create
  "Creates the annotations layer."
  [mission {:keys [map-viewbox map-zoom] :as state}]
  (let [state (assoc state :annotations (cell (sorted-map)))]
    {:controls-fn (fn [] (controls state))
     :overlay-fn  (fn [register-drag-handler]
                    (overlay state register-drag-handler))
     :state       state}))

(defn briefing-data
  "Returns data for saving in a briefing file."
  [layer]
  {:annotations (->> layer
                     :state
                     :annotations
                     deref
                     (reduce-kv (fn [annotations k annotation]
                                  (assoc annotations k (assoc annotation :editing? false)))
                                (sorted-map)))})

(defn load-briefing-data
  "Given briefing data, update the layer with the state from it."
  [this data]
  (reset! (get-in this [:state :annotations])
          (or (:annotations data) (sorted-map))))
