(ns weathergen.ui.layers.annotations
  "Responsible for drawing the map annotations and the associated
  controls. Annotations are informational overlays added to the map:
  squares, ovals, text, lines, etc."
  (:require [clojure.pprint :refer [pprint]]
            [goog.string :as gstring]
            [goog.string.format]
            [hoplon.svg :as svg]
            [weathergen.help :as help :refer [with-help]]
            [weathergen.math :as math]
            [weathergen.ui.buttons :as buttons]
            [weathergen.ui.common :as comm :refer [colors control-section
                                                   dropdown
                                                   ems
                                                   get-image
                                                   format-time inl
                                                   map-lens
                                                   path-lens pct pre-cell px
                                                   styled team-color triangle
                                                   validating-edit]]
            [weathergen.ui.tabs :as tabs])
  (:require-macros
   [weathergen.cljs.macros :refer [hint->
                                   hint->>
                                   keyed-for-tpl
                                   with-attr-bindings
                                   with-bbox
                                   with-default-lenses
                                   with-key-lenses
                                   with-time]]))

(comm/register-class!
 ::no-focus-border
 [:&:hover {:outline "none"}])

;;; Overlay

(def font-scale-factor
  7.87406581267874E-4)

;; TODO: Convert these to use linear->exp and exp->linear, below
(let [base 1.0875853314770578
      factor font-scale-factor]
  (defn- font-size->scale
    [font-size]
    (-> (Math/pow base font-size)
        (* factor)))

  (defn- scale->font-size
    [scale]
    (-> scale
        (/ factor)
        Math/log
        (/ (Math/log base)))))

(defn- linear->exp
  "Converts `val`, a value on the linear interval `linear-min` to
  `linear-max`, exponentially along the interval `exp-min` to
  `exp-max`."
  [val linear-min linear-max exp-min exp-max]
  (let [a (/ exp-max exp-min)
        b (Math/pow a (/ 1.0 (- linear-max linear-min)))
        c (/ exp-min (Math/pow b linear-min))]
    (* c (Math/pow b val))))

(defn- exp->linear
  "Complement of `linear->exp`."
  [val linear-min linear-max exp-min exp-max]
  (let [a (/ exp-max exp-min)
        b (Math/pow a (/ 1.0 (- linear-max linear-min)))
        c (/ exp-min (Math/pow b linear-min))]
    (/ (Math/log (/ val c))
       (Math/log b))))

(defn- contents-overlay
  "Returns SVG for the contents of the annotation"
  [{:keys [suppress-bullseye-info-box? dragging]} annotation]
  (with-key-lenses annotation
    [background
     border-color border-width border-style border-dash-length border-dash-spacing
     editing?
     font-bold? font-color font-italic? font-family font-size
     halign
     height
     text
     type
     valign
     width]
    (with-default-lenses
      {border-width        0
       border-dash-length  0
       border-dash-spacing 0
       width               0
       height              0}
      (let [bw     (formula-of [border-style border-width]
                     (if (= :none border-style)
                       0
                       (/ border-width 200)))
            offset (cell= (/ bw 2))
            w      (cell= (max 0 (- width bw)))
            h      (cell= (max 0 (- height bw)))]
        (svg/g
         :stroke (cell= (comm/to-rgba border-color))
         :stroke-width bw
         :fill (cell= (comm/to-rgba background))
         :stroke-dasharray (formula-of [border-style border-dash-length border-dash-spacing]
                             (when (= border-style :dashed)
                               (let [dash-length (linear->exp border-dash-length
                                                              1 100
                                                              0.005 10)
                                     gap-length  (* dash-length (linear->exp border-dash-spacing
                                                                             1 100
                                                                             0.01 100))]
                                 (str dash-length
                                      " "
                                      gap-length))))
         (case-tpl type
           :oval (svg/ellipse
                  :x offset
                  :y offset
                  :cx (cell= (/ w 2))
                  :cy (cell= (/ h 2))
                  :rx (cell= (/ w 2))
                  :ry (cell= (/ h 2)))
           :rectangle (svg/rect
                       :x offset
                       :y offset
                       :width w
                       :height h))
         (let [editing-text? (cell false)
               scale-factor  (formula-of [font-size]
                               (font-size->scale font-size))]
           (svg/g
            :transform (cell= (comm/svg-scale scale-factor))
            (let [fo-width  (cell= (/ width scale-factor))
                  fo-height (cell= (/ height scale-factor))]
              (with-let [fo (svg/foreignObject
                             :width fo-width
                             :height fo-height)]
                (let [text-y (cell 0)]
                  (fo
                   :y text-y
                   (with-let [elem (div :class (comm/class-for ::no-focus-border))]
                     (do-watch (formula-of [annotation scale-factor fo-height]
                                 {:scale-factor scale-factor
                                  :annotation annotation
                                  :fo-height fo-height})
                               (fn [_ {:keys [scale-factor annotation fo-height]}]
                                 (let [{:keys [height valign]} annotation]
                                   (with-timeout 0
                                     (reset! text-y
                                             (cond
                                               (= valign :bottom)
                                               (- fo-height (.-clientHeight elem))

                                               (= valign :middle)
                                               (/ (- fo-height (.-clientHeight elem)) 2)

                                               :else
                                               0))))))
                     (elem
                      :xmlns "http://www.w3.org/1999/xhtml"
                      :contenteditable (when-tpl editing-text? "true")
                      :click (fn []
                               (reset! editing-text? true)
                               (with-timeout 0
                                 (.focus elem)))
                      :keyup (fn [^KeyboardEvent e]
                               (when (= comm/ESCAPE_KEY (.-keyCode e))
                                 (dosync
                                  (reset! text (-> elem .-innerText))
                                  (reset! editing-text? false))))
                      :mousemove (fn [e]
                                   (reset! suppress-bullseye-info-box? true)
                                   (.preventDefault e)
                                   false)
                      :blur (fn [e]
                              (dosync
                               (reset! text (-> elem .-innerText))
                               (reset! editing-text? false)))
                      :css (formula-of [font-bold? font-family font-italic? font-color font-size
                                        editing? dragging halign]
                             {:white-space    "pre-wrap"
                              :pointer-events (if (and editing? (nil? dragging)) "all" "none")
                              :cursor         (when editing? "text")
                              :font-family    font-family
                              :font-weight    (when font-bold? "bold")
                              :font-style     (when font-italic? "italic")
                              :padding        (ems 0 0.2)
                              :color          (comm/to-rgba font-color)
                              :text-align     halign})
                      text)))))))))))))

(defn- overlay
  "Renders the UI for the display of the annotations."
  [{:keys [annotations map-viewbox map-zoom] :as state}
   register-drag-handler]
  (svg/g
   :id "annotations-overlay"
   (keyed-for-tpl key
     [[k _] annotations]
     (let [annotation (comm/map-lens annotations k)]
       (with-key-lenses annotation
         [type
          font-size
          font-family
          font-color
          background
          text
          x
          y
          width
          height
          rotation
          editing?
          hidden?]
         (with-default-lenses
           {x         0
            y         0
            width     0
            height    0
            rotation  0
            font-size 0}
           (let [dragging (cell nil)]
             (svg/g
              :css (formula-of [editing? hidden?]
                     {:display (when (and (not editing?) hidden?)
                                 "none")})
              :transform (cell= (comm/svg-translate x y))
              (svg/g
               :transform (cell= (comm/svg-rotate rotation))
               (svg/g
                :transform (cell= (comm/svg-translate (/ width -2) 0))
                (let [state* (assoc state :dragging dragging)]
                  (contents-overlay state* annotation))
                (when-tpl editing?
                  (let [large-border-width (cell= (/ 0.2 map-zoom))
                        small-border-width (cell= (* large-border-width 0.65))
                        outer-width        (cell= (+ width (* 2 large-border-width)))
                        outer-height       (cell= (+ height (* 2 large-border-width)))
                        size               (cell= (/ 1.7 map-zoom))]
                    (svg/g
                     :debug "edit controls"
                     (let [path (formula-of [outer-width large-border-width size]
                                  (let [x (- (/ outer-width 2) large-border-width)
                                        y (* size -2.5)]
                                    (str "M" x ",0"
                                         " L" x "," y)))]
                       (svg/g
                        :debug "edit border"
                        (svg/path
                         :stroke "lightblue"
                         :fill "none"
                         :stroke-width large-border-width
                         :d path)
                        (svg/path
                         :stroke "blue"
                         :fill "none"
                         :stroke-width small-border-width
                         :d path)
                        (svg/rect
                         :width (cell= (- outer-width large-border-width))
                         :height (cell= (- outer-height large-border-width))
                         :x (cell= (* large-border-width -0.5))
                         :y (cell= (* large-border-width -0.5))
                         :stroke "lightblue"
                         :fill "none"
                         :stroke-width large-border-width)
                        (svg/rect
                         :width (cell= (- outer-width large-border-width))
                         :height (cell= (- outer-height large-border-width))
                         :x (cell= (* large-border-width -0.5))
                         :y (cell= (* large-border-width -0.5))
                         :stroke "blue"
                         :fill "none"
                         :stroke-width small-border-width)
                        (let [button (fn [{:keys [x y name src drag click]}]
                                       (svg/g
                                        :debug name
                                        :transform (cell= (comm/svg-translate x y))
                                        :mousedown (fn [_]
                                                     (when drag
                                                       (register-drag-handler
                                                        (let [drag-fn (drag)]
                                                          (reset! dragging name)
                                                          (fn [dpos final?]
                                                            (drag-fn dpos final?)
                                                            (when final?
                                                              (reset! dragging nil)))))))
                                        :click (fn [_]
                                                 (when click (click)))
                                        (svg/rect
                                         :x 0
                                         :y 0
                                         :width size
                                         :height size
                                         :stroke "black"
                                         :fill (formula-of [dragging]
                                                 (if (= dragging name)
                                                   "lightblue"
                                                   "white"))
                                         :stroke-width (cell= (/ 0.1 map-zoom)))
                                        (svg/image
                                         :xlink-href src
                                         :x (cell= (* size 0.1))
                                         :y (cell= (* size 0.1))
                                         :width (cell= (* size 0.8))
                                         :height (cell= (* size 0.8)))))]
                          (svg/g
                           :debug (cell= (str "edit buttons. Dragging: " (pr-str dragging)))
                           (button {:name "Move"
                                    :x    (cell= (- (+ size (/ large-border-width 2))))
                                    :y    (cell= (- (+ size (/ large-border-width 2))))
                                    :src  "images/move.svg"
                                    :drag (fn []
                                            (let [x0 (:x @annotation)
                                                  y0 (:y @annotation)]
                                              (fn [[dx dy] final?]
                                                (swap! annotation
                                                       assoc
                                                       :x (+ x0 dx)
                                                       :y (+ y0 dy)))))})
                           (button {:name "Rotate"
                                    :x    (cell= (+ (/ width 2) (/ size -2)))
                                    :y    (cell= (- (+ (* size 3) (/ large-border-width 2))))
                                    :src  "images/rotate.svg"
                                    :drag (fn []
                                            (let [theta0 @rotation
                                                  pivot  (math/rotate (- theta0) [0 (* @size -2.5)])]
                                              (fn [[dx dy :as dp] final?]
                                                (let [[x1 y1]   (math/vector-add dp pivot)
                                                      theta1    (math/heading [x1 (- y1)])]
                                                  (swap! annotation
                                                         assoc
                                                         :rotation (mod theta1 360))))))})


                           (button {:name "Resize Text"
                                    :x    (cell= (+ size (/ large-border-width -2)))
                                    :y    (cell= (- (+ size (/ large-border-width 2))))
                                    :src  "images/text-resize.svg"
                                    :drag (fn []
                                            (let [extent (* 0.5 (:width @map-viewbox))
                                                  size0  @font-size]
                                              (fn [[dx dy] final?]
                                                (reset! font-size
                                                        (-> dx
                                                            (/ extent)
                                                            (* 100)
                                                            (+ size0)
                                                            (max 1)
                                                            (min 100))))))})
                           (button {:name  "Done"
                                    :x     (cell= (- (+ size (/ large-border-width 2))))
                                    :y     (cell= (+ height (/ large-border-width 2)))
                                    :src   "images/checkmark.png"
                                    :click #(reset! editing? false)})
                           (button {:name  "Delete"
                                    :x     (cell= (+ size (/ large-border-width -2)))
                                    :y     (cell= (+ height (/ large-border-width 2)))
                                    :src   "images/trash.png"
                                    :click #(swap! annotations dissoc @k)})
                           (button {:name "Resize"
                                    :x    (cell= (+ width (/ large-border-width 2)))
                                    :y    (cell= (+ height (/ large-border-width 2)))
                                    :src  "images/resize.svg"
                                    :drag (fn []
                                            (let [w0     @width
                                                  h0     @height
                                                  theta0 @rotation]
                                              (fn [dpos final?]
                                                (let [[dx' dy'] (math/rotate theta0 dpos)
                                                      w         (+ w0 (* dx' 2))
                                                      h         (+ h0 dy')]
                                                  (swap! annotation
                                                         assoc
                                                         :width (max 0 w)
                                                         :height (max 0 h))))))}))))))))))))))))))

;;; Controls

(defn- coord-edit
  "Returns UI for a coordinate edit over `source`."
  [source]
  (validating-edit
   :width 50
   :source source
   :conform comm/conform-nonnegative-float
   :placeholder "0.00"
   :fmt (fn [v] (.toFixed v 2))))

(defn- location-controls
  "Returns UI for the location of an annotation."
  [annotation]
  (with-key-lenses annotation [x y]
    (with-default-lenses
      {x 0
       y 0}
      (tr (td (with-help [:map-controls :annotations :location]
                "Location:"))
          (td (coord-edit x))
          (td (coord-edit y))))))

(defn- size-controls
  "Returns UI for the size of an annotation."
  [annotation]
  (with-key-lenses annotation [width height]
    (with-default-lenses
      {width  0
       height 0}
      (tr (td (with-help [:map-controls :annotations :size]
                "Size:"))
          (td (coord-edit width))
          (td (coord-edit height))))))

(defn- rotation-controls
  "Returns UI for the rotation of an annotation."
  [annotation]
  (with-key-lenses annotation [rotation]
    (with-default-lenses
      {rotation 0}
      (tr (td (with-help [:map-controls :annotations :rotation]
                "Rotation:"))
          (td (validating-edit
               :width 50
               :source rotation
               :conform (comm/float-conformer -360 360)
               :placeholder "0.00"
               :fmt (fn [v] (.toFixed v 2))))))))

(defn- range-controls
  "Returns UI for a range slider that moves between 1 and 100."
  [label help-tag source]
  (tr (td (with-help [:map-controls :annotations help-tag]
            label))
      (td (comm/slider
           :css {:width (px 70)}
           :value source
           :min 1
           :max 100))
      (td (validating-edit
           :source source
           :width 50
           :placeholder "0.00"
           :conform (comm/float-conformer 1 100)
           :fmt (fn [v] (.toFixed v 2))))))

(defn- color-controls
  "Returns UI for a color picker control."
  [label help-tag source]
  (tr (td (with-help [:map-controls :annotations help-tag]
            label))
      (td (comm/color-picker2
           :value source
           :alpha? true))
      (td (validating-edit
           :width 70
           :source source
           :conform (fn [source*]
                      (formula-of [source*]
                        (let [c      (comm/tinycolor source*)
                              valid? (.isValid c)]
                          {:valid?  valid?
                           :message (when-not valid? "Must be a valid color")
                           :value   source*})))
           :placeholder "#aarrggbb"
           :fmt identity))))

(defn- text-annotation-controls
  "Returns UI for the controls used to render a text annotation."
  [annotation]
  (with-key-lenses annotation
    [background
     font-size font-family font-color font-bold? font-italic?
     halign
     height
     rotation
     text
     valign
     width]
    (with-default-lenses
      {font-size 0}
      (table
       (range-controls "Font Size:" :font-size font-size)
       (tr (td (with-help [:map-controls :annotations :font]
                 "Font:"))
           (td :colspan 2
               (comm/select2
                :css {:width (pct 100)}
                :value font-family
                :choices (for [font ["Arial"
                                     "Bookman"
                                     "Comic Sans MS"
                                     "Courier"
                                     "Courier New"
                                     "Garamond"
                                     "Georgia"
                                     "Helvetica"
                                     "Palatino"
                                     "Times"
                                     "Times New Roman"
                                     "Verdana"]]
                           {:value font
                            :label font})
                :formatter (fn [{:keys [label]}]
                             (span :css {:font-family label}
                                   label)))))
       (tr (td (with-help [:map-controls :annotations :halign]
                 "Horizontal alignment:"))
           (td :colspan 2
               (comm/select2
                :css {:width (pct 100)}
                :value halign
                :choices [{:value "left"
                           :label "Left"}
                          {:value "center"
                           :label "Center"}
                          {:value "right"
                           :label "Right"}])))
       (tr (td (with-help [:map-controls :annotations :valign]
                 "Vertical alignment:"))
           (td :colspan 2
               (comm/select2
                :css {:width (pct 100)}
                :value valign
                :choices [{:value :top
                           :label "Top"}
                          {:value :middle
                           :label "Middle"}
                          {:value :bottom
                           :label "Bottom"}])))
       (tr (td (with-help [:map-controls :annotation :font-bold?]
                 "Bold?:"))
           (td (comm/checkbox :value font-bold?)))
       (tr (td (with-help [:map-controls :annotation :font-italic?]
                 "Italic?:"))
           (td (comm/checkbox :value font-italic?)))
       (color-controls "Color:" :color font-color)
       (tr (td (with-help [:map-controls :annotations :text]
                 "Text:"))
           (td :colspan 2
               (with-let [elem (textarea)]
                 (do-watch text
                           (fn [_ _]
                             (with-timeout 0
                               (-> elem
                                   js/jQuery
                                   (.css #js {:height     "auto"
                                              :overflow-y "hidden"})
                                   (.height (max 20 (.-scrollHeight elem)))))))
                 (elem
                  :css (formula-of [font-family font-italic? font-bold?]
                         {:font-family          font-family
                          :font-style           (when font-italic? "italic")
                          :font-weight          (when font-bold? "bold")
                          :font-size            (pct 100)
                          :width                (pct 100)
                          :horizontal-alignment halign})
                  :value text
                  :placeholder "Enter text here"
                  :input #(reset! text @%)))))))))

(defn- arrow-annotation-controls
  "Returns UI for the controls used to render an arrow annotation."
  [annotation]
  [(tr (td "TODO")
       (td "TODO"))])

(defn- image-annotation-controls
  "Returns UI for the controls used to render an image annotation."
  [annotation]
  [(tr (td "TODO")
       (td "TODO"))])

(defn- border-controls
  "Returns UI for the controls used to set up borders."
  [annotation]
  (with-key-lenses annotation
    [border-style
     border-width
     border-color
     border-dash-length
     border-dash-spacing]
    (with-default-lenses
      {border-width        0
       border-dash-length  0
       border-dash-spacing 0}
      (table
       (let [dashed?     (cell= (= border-style :dashed))
             has-border? (cell= (#{:dashed :solid} border-style))]
         (tbody
          (tr (td (with-help [:map-controls :annotations :border-style]
                    "Border style:"))
              (td :colspan 2
                  (comm/select2
                   :css {:width (pct 100)}
                   :value border-style
                   :choices [{:value :none
                              :label "No Border"}
                             {:value :solid
                              :label "Solid"}
                             {:value :dashed
                              :label "Dashed"}]
                   :formatter :label)))
          (when-tpl has-border?
            (color-controls "Border color:" :border-color border-color))
          (when-tpl has-border?
            (range-controls "Border width:" :border-width border-width))
          (when-tpl dashed?
            (range-controls "Dash length:" :border-dash-length border-dash-length))
          (when-tpl dashed?
            (range-controls "Dash spacing:" :border-dash-spacing border-dash-spacing))))))))

(defn- controls
  "Returns UI for the map annotation controls."
  [{:keys [annotations map-viewbox] :as state}]
  (control-section
   :title (with-help [:map-controls :annotations :overview]
            "Annotations")
   (div
    (div
     :css {:display   "flex"
           :flex-wrap "wrap"}
     (keyed-for-tpl key
       [[k _] annotations]
       (let [annotation (map-lens annotations k)]
         (with-key-lenses annotation [type editing? hidden? background]
           (do-watch type
                     (fn [_ n]
                       #_(.log js/console "Type has changed to" (pr-str n)
                               "border-width" (pr-str (:border-width n)))
                       (cond
                         (= n :rectangle)
                         (swap! annotation
                                #(cond-> %
                                   (nil? (:border-width %))
                                   (assoc :border-width (/ (:font-size %) 6))

                                   (nil? (:border-dash-length %))
                                   (assoc :border-dash-length (:font-size %))

                                   (nil? (:border-dash-spacing %))
                                   (assoc :border-dash-spacing 50))))))
           (div
            :css (formula-of [hidden?]
                   {:border-width  (px 3)
                    :border-style  (if hidden? "dashed" "double")
                    :border-color  "grey"
                    :padding       (px 0 5 30)
                    :margin-bottom (px 3)
                    :margin-right  (px 3)
                    :min-width     (px 350)
                    :min-height    (px 330)
                    :position      "relative"})
            (div
             :css {:margin (px 5 0 15 7)}
             (inl
              {:css {:margin-right (px 10)}}
              (with-help [:map-controls :annotations :type]
                "Type:"))
             (inl
              (comm/select2
               :value type
               :choices [{:value :rectangle
                          :label "Rectangle"}
                         {:value :arrow
                          :label "Arrow"}
                         {:value :oval
                          :label "Oval"}
                         {:value :image
                          :label "Image"}])))
            (tabs/tabs
             :selected (cell :shape)
             :tabs
             [{:id    :shape
               :title "Positioning"
               :ui
               (table
                (location-controls annotation)
                (size-controls annotation)
                (rotation-controls annotation))}
              {:id    :border
               :title "Border"
               :ui    (border-controls annotation)}
              {:id    :background
               :title "Background"
               :ui
               (table
                (color-controls "Color:" :background background))}
              {:id    :text
               :title "Text"
               :ui    (text-annotation-controls annotation)}
              {:id    :debug
               :title "Debug"
               :ui    (pre
                       :css {:white-space "pre-wrap"}
                       (cell= (with-out-str (pprint annotation))))}])
            (buttons/image-button
             :css {:position "absolute"
                   :bottom   (px 5)}
             :click #(swap! editing? not)
             :title "Edit"
             :src "images/edit.svg"
             :width "16px"
             :height "16px"
             :latched? editing?)
            (buttons/image-button
             :css {:position "absolute"
                   :bottom   (px 5)
                   :left     (px 32)}
             :click #(swap! hidden? not)
             :title "Hide"
             :src "images/hide-eye.svg"
             :width "16px"
             :height "16px"
             :latched? hidden?)
            (buttons/image-button
             :css {:position "absolute"
                   :bottom   (px 5)
                   :right    (px 5)}
             :src "images/trash.png"
             :width "16px"
             :title "Remove"
             :click #(swap! annotations
                            dissoc
                            @k)))))))
    (buttons/a-button
     :click #(let [{:keys [x y width height]} @map-viewbox]
               (swap! annotations
                      assoc
                      (->> @annotations
                           keys
                           (reduce max 0)
                           inc)
                      {:type         :rectangle
                       :text         "Edit this text"
                       :font-size    (scale->font-size (/ width 59 4))
                       :font-color   "white"
                       :font-family  "Times New Roman"
                       :halign       "center"
                       :valign       :middle
                       :background   "#80000000"
                       :x            (+ x (/ width 2))
                       :y            (+ y (/ height 2.0))
                       :width        (/ width 2)
                       :height       (/ height 12)
                       :rotation     0
                       :editing?     true
                       :hidden?      false
                       :border-style :solid
                       :border-color "black"}))
     "Add New"))))

(defn create
  "Creates the annotations layer."
  [mission {:keys [map-viewbox map-zoom] :as state}]
  (let [state (assoc state :annotations (cell (sorted-map)))]
    {:controls-fn (fn [] (controls state))
     :overlay-fn  (fn [register-drag-handler]
                    (overlay state register-drag-handler))
     :state       state}))

(defn briefing-data
  "Returns data for saving in a briefing file."
  [layer]
  {:annotations (->> layer
                     :state
                     :annotations
                     deref
                     (reduce-kv (fn [annotations k annotation]
                                  (assoc annotations k (assoc annotation :editing? false)))
                                (sorted-map)))})

(defn load-briefing-data
  "Given briefing data, update the layer with the state from it."
  [this data]
  (reset! (get-in this [:state :annotations])
          (or (:annotations data) (sorted-map))))
