(page "test.html"
  (:require [clojure.string :as str]
            ;; [cljsjs.pako]
            [goog.crypt.base64 :as base64]
            [hoplon.storage-atom :refer [local-storage]]
            [weathergen.coordinates :as coords]
            [weathergen.database :as db]
            [weathergen.falcon.install :as install]
            [weathergen.falcon.files.mission :as mission]
            [weathergen.help :as help]
            [weathergen.math :as math]
            [weathergen.model :as model]
            [weathergen.ui :as ui]
            [weathergen.ui.buttons :as buttons]
            [weathergen.ui.common :as comm :refer [px]]
            [weathergen.ui.grids :as grids]
            [weathergen.ui.layers.flights :as flights])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [weathergen.cljs.macros :refer [with-time formula-of]]))

;; (reset! ui/max-time {:day 2 :hour 2 :minute 2})

;; (reset! ui/weather-params
;;         ui/default-weather-params)

;; (ui/weather-page
;;  :test-section {})

(def hidden-columns
  (local-storage
   (cell #{:bar :baaz})
   (str ::hidden-columns)))

(def movable-columns
  (local-storage
   (cell [:foo :bar :baaz :quux])
   (str ::movable-columns2)))

(defc installations nil)

(install/locate-installations
 (fn [installs]
   (reset! installations installs)))

(defn load-mission
  [mission]
  (when-let [[path] (-> "electron"
                        js/require
                        .-remote
                        .-dialog
                        (.showOpenDialog
                         (clj->js {:title      "Select a campaign or tactical engagement file"
                                   :properties ["openFile"]
                                   :filters    [{:name       "Campaign file"
                                                 :extensions ["cam"]}
                                                {:name       "Tactical engagement file"
                                                 :extensions ["tac"]}]})))]
    (reset! mission (with-time "read-mission"
                      (mission/read-mission @installations path)))))

(html
 (ui/head)
 (let [b (body)]
   (b
    (let [mission      (cell nil)
          flight-layer (flights/create mission
                                       {:map-zoom          (cell 1.0)
                                        :visible-teams     (formula-of [mission]
                                                             (->> mission mission/teams (map mission/team-number) set))
                                        :map-text-scale    (cell 1.0)
                                        :flight-path-scale (cell 1.0)})]
      (formula-of [mission]
        (.log js/console (clj->js (map mission/team-number (mission/teams mission)))))
      (div
       (buttons/a-button
        :click #(with-time "load-mission"
                  (load-mission mission))
        "Load")
       (let [x (cell "hi")]
         (div (formula-of [x] (str x " there"))))
       (let [val (cell nil)
             choices (cell [{:value :yes
                             :label "Yes"}
                            {:value :no
                             :label "No"}])]
         (div
          (div (cell= (pr-str val)))
          (buttons/a-button :click #(reset! val :no) "No")
          (buttons/a-button :click #(reset! val :yes) "Yes")
          (comm/radio-group :value val
                            :choices choices)
          (comm/radio-group :value val
                            :choices choices)))
       (let [latched? (cell false)]
         (buttons/rimage-button {:title    "test title"
                                 :latched? latched?
                                 :on-click (fn [e] (swap! latched? not))}))
       #_(with-let [parent (div)]
           (rum.core/mount (help/RHelp2 [:div "Testing"])
                           parent))
       #_(help/with-rhelp [:wind-stability-areas]
           [:div "hi2"])
       (let [ctor (:controls-fn flight-layer)]
         (ctor b))
       (hr)
       (let [filter? (cell false)
             data    (formula-of [filter?]
                       (->> (for [n (range 100)]
                              {:id n
                               :a  n
                               :b  (- 100 n)
                               :c  (str (rand-int 1000))})
                            (filter (fn [{:keys [a]}]
                                      (if filter?
                                        (even? a)
                                        true)))
                            (into [])))]
         (div
          (buttons/a-button
           :latched? filter?
           :click #(swap! filter? not)
           "Filtered?")
          (grids/table-grid
           {:data            data
            :row-attrs       (fn [id] {})
            :when-empty      "I am empty"
            :columns         {:a {:title     "A"
                                  :sort-key  :a
                                  :formatter #(-> % :a str cell= div)}
                              :b {:title     "B"
                                  :sort-key  :b
                                  :formatter #(-> % :b str cell= div)}
                              :c {:title     "C"
                                  :sort-key  :c
                                  :formatter #(-> % :c str cell= div)}}
            :fixed-columns   [:b]
            :movable-columns (cell [:a :c])
            :hidden-columns  (cell #{:c})})))
       #_(grids/rtable-grid
          {:data            (cell (into []
                                        (for [n (range 100)]
                                          {:id n
                                           :a  n
                                           :b  (- 100 n)
                                           :c  (str (rand-int 1000))}
                                          )) #_[{:id 1 :a 1 :b 2 :c "three"}
                                        {:id 2 :a 3 :b 1 :c "four"}
                                        {:id 3 :a 2 :b 4}])
           :key-fn          :id
           :row-attrs       (fn [id] {})
           :when-empty      "I am empty"
           :columns         {:a {:title     "A"
                                 :sort-key  :a
                                 :formatter #(-> % :a str)}
                             :b {:title     "B"
                                 :sort-key  :b
                                 :formatter #(-> % :b str)}
                             :c {:title     "C"
                                 :sort-key  :c
                                 :formatter #(-> % :c str)}}
           :fixed-columns   [:b]
           :movable-columns (cell [:a :c])
           :hidden-columns  (cell #{:c})})
       #_(hr)
       #_(grids/table-grid
          {:data            (cell (into []
                                        (for [n (range 100)]
                                          {:id n
                                           :a  n
                                           :b  (- 100 n)
                                           :c  (str (rand-int 1000))}
                                          )) #_[{:id 1 :a 1 :b 2 :c "three"}
                                        {:id 2 :a 3 :b 1 :c "four"}
                                        {:id 3 :a 2 :b 4}])
           :row-attrs       (fn [id] {})
           :when-empty      "I am empty"
           :columns         {:a {:title     "A"
                                 :sort-key  :a
                                 :formatter #(-> % :a str cell= div)}
                             :b {:title     "B"
                                 :sort-key  :b
                                 :formatter #(-> % :b str cell= div)}
                             :c {:title     "C"
                                 :sort-key  :c
                                 :formatter #(-> % :c str cell= div)}}
           :fixed-columns   [:b]
           :movable-columns (cell [:a :c])
           :hidden-columns  (cell #{:c})})))
    #_(hr)
    #_(with-let [parent (.createElement js/document "div")]
        (rum.core/mount
         (grids/RSimpleGrid
          (into []
                (for [n (range 100)]
                  {:id n
                   :a  n
                   :b  (- 100 n)
                   :c  (str (rand-int 1000))}
                  ))
          [:id :a :b :c])
         parent))
    #_(let [latched? (cell false)
            element  (div
                      :class "element"
                      :css {:background "green"
                            :color      "white"
                            :width      (px 100)
                            :height     (px 100)}
                      "Element")
            content  (div
                      :class "content"
                      :css {:background "yellow"
                            :color      "black"
                            :width      (px 200)
                            :height     (px 150)}
                      "Content")
            ;; element (div
            ;;          (div
            ;;           :toggle latched?
            ;;           :css {:background "white"
            ;;                 :border-color "black"
            ;;                 :border-width (px 1)}
            ;;           "This is some content"))
            ;; toggler (div
            ;;          (buttons/a-button
            ;;           :click #(swap! latched? not)
            ;;           :latched? latched?
            ;;           :css {:border-radius "50%"
            ;;                 :width (px 15)
            ;;                 :height (px 15)
            ;;                 :text-align "center"
            ;;                 :font-weight "bold"
            ;;                 :font-family "serif"
            ;;                 :line-height (px 12)}
            ;;           (div
            ;;            :css {:border-radius "50%"
            ;;                  :width (px 15)
            ;;                  :height (px 15)
            ;;                  :text-align "center"
            ;;                  :font-weight "bold"
            ;;                  :font-family "serif"
            ;;                  :line-height (px 12)
            ;;                  :color "white"
            ;;                  :background "blue"
            ;;                  :border-color "white"
            ;;                  :border-with (px 2)}
            ;;            "i")))
            ]
        (div
         :css {:position "relative"}
         element
         content))
    #_(grids/table-grid
       :data [{:foo  1
               :bar  2
               :baaz "a"
               :quux "hi"}
              {:foo  3
               :bar  4
               :baaz "b"
               :quux "there"}
              {:foo  10
               :bar  2034234
               :baaz "c"
               :quux "long words"}]
       :row-attrs (constantly {})
       :hidden-columns hidden-columns
       :fixed-columns (cell [])
       :movable-columns movable-columns
       :columns {:foo  {:title     "foo"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:foo item)))
                        :sort-key  :foo
                        :css       (fn [item rownum]
                                     (formula-of [item rownum]
                                       {:background-color (if (odd? rownum)
                                                            "purple"
                                                            "pink")}))}
                 :bar  {:title     "bar"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:bar item)))
                        :sort-key  :bar}
                 :baaz {:title     "baaz"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:baaz item)))
                        :sort-key  :baaz}
                 :quux {:title     "quux"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:quux item)))
                        :sort-key  :quux}}))))

