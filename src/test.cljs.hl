(page "test.html"
  (:require [clojure.pprint :refer [pprint]]
            [clojure.string :as str]
            ;; [cljsjs.pako]
            [goog.crypt.base64 :as base64]
            [goog.string :as gstring]
            [goog.string.format]
            [hoplon.storage-atom :refer [local-storage]]
            [weathergen.coordinates :as coords]
            [weathergen.database :as db]
            [weathergen.falcon.install :as install]
            [weathergen.falcon.files.mission :as mission]
            [weathergen.help :as help]
            [weathergen.math :as math]
            [weathergen.model :as model]
            [weathergen.ui :as ui]
            [weathergen.ui.buttons :as buttons]
            [weathergen.ui.common :as comm :refer [px]]
            [weathergen.ui.grids :as grids]
            [weathergen.ui.layers.flights :as flights])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [weathergen.cljs.macros :refer [with-time formula-of keyed-for-tpl]]))

;; (reset! ui/max-time {:day 2 :hour 2 :minute 2})

;; (reset! ui/weather-params
;;         ui/default-weather-params)

;; (ui/weather-page
;;  :test-section {})

(def hidden-columns
  (local-storage
   (cell #{:bar :baaz})
   (str ::hidden-columns)))

(def movable-columns
  (local-storage
   (cell [:foo :bar :baaz :quux])
   (str ::movable-columns2)))

(defc installations nil)

(install/locate-installations
 (fn [installs]
   (reset! installations installs)))

(defn load-mission
  [mission]
  (when-let [[path] (-> "electron"
                        js/require
                        .-remote
                        .-dialog
                        (.showOpenDialog
                         (clj->js {:title      "Select a campaign or tactical engagement file"
                                   :properties ["openFile"]
                                   :filters    [{:name       "Campaign file"
                                                 :extensions ["cam"]}
                                                {:name       "Tactical engagement file"
                                                 :extensions ["tac"]}]})))]
    (reset! mission (with-time "read-mission"
                      (mission/read-mission @installations path)))))

(html
 (ui/head)
 (let [b (body)]
   (b
    (let [mission      (cell nil)
          flight-layer (flights/create mission
                                       {:map-zoom          (cell 1.0)
                                        :visible-teams     (formula-of [mission]
                                                             (->> mission mission/teams (map mission/team-number) set))
                                        :map-text-scale    (cell 1.0)
                                        :flight-path-scale (cell 1.0)})]
      (formula-of [mission]
        (.log js/console (clj->js (map mission/team-number (mission/teams mission)))))
      (div
       (buttons/a-button
        :click #(with-time "load-mission"
                  (load-mission mission))
        "Load")
       (hr)
       (let [items (cell (for [n (range 20)]
                           {:key  n
                            :text (gstring/format "%02d" n)}))]
         (div
          (div
           (pre :css {:white-space "pre-wrap"}
                (cell= (with-out-str (pprint items))))
           (buttons/a-button
            :click #(swap! items shuffle)
            "Shuffle")
           (buttons/a-button
            :click #(swap! items (fn [items]
                                   (sort-by :key items)))
            "Sort")
           (buttons/a-button
            :click #(swap! items
                           (fn [items]
                             (if (empty? items)
                               items
                               (let [n (rand-int (count items))]
                                 (.log js/console "Removing" n)
                                 (concat (take n items) (drop (inc n) items))))))
            "Remove one")
           (buttons/a-button
            :click #(swap! items
                           (fn [items]
                             (let [n (rand-int (count items))]
                               (.log js/console "Inserting" n)
                               (concat (take n items)
                                       [{:key  (->> items
                                                    (map :key)
                                                    (reduce max 0)
                                                    inc)
                                         :text "inserted"}]
                                       (drop n items)))))
            "Insert one"))
          (table
           (tbody
            (for-tpl [item items]
              (tr (td (cell= (:key item)))
                  (td (cell= (:text item)))))
            #_(keyed-for-tpl :key
                [item items]
                (.log js/console "item" (pr-str item))
                (tr (td (cell= (:key item)))
                    (td (cell= (:text item)))))))))
       (hr)
       (let [v (cell "Arial")]
         (div
          (div v
               (buttons/a-button
                :click #(reset! v "Arial")
                "Reset"))
          (comm/select2
           :css {:width (px 170)}
           :value v
           :data (for [font ["Arial"
                             "Bookman"
                             "Comic Sans MS"
                             "Courier"
                             "Courier New"
                             "Garamond"
                             "Georgia"
                             "Helvetica"
                             "Palatino"
                             "Times"
                             "Times New Roman"
                             "Verdana"]]
                   {:value font
                    :label font})
           :formatter (fn [{:keys [label]}]
                        (span :css {:font-family label}
                              label)))))
       (hr)
       (let [c  (cell "#abcdef")
             c2 (cell "#123456")]
         (div
          (div c)
          (buttons/a-button
           :click #(reset! c "#000000")
           "Reset")
          (with-let [elem (div)]
            (when-dom elem
              #(elem #_(cell= (pr-str c2))
                     (comm/color-picker2
                      :value c
                      :alpha? true))))))
       (hr)
       (let [c  (cell "#abcdef")
             id (str (gensym))]
         (div
          (cell= (pr-str c))
          (buttons/a-button
           :click #(reset! c "red")
           "Reset")
          (comm/color-picker2 :value c :alpha? true)))
       (hr)
       (let [filter? (cell false)
             data    (cell (->> (for [n (range 10)]
                                  {:id n
                                   :a  n
                                   :b  (- 100 n)
                                   :c  (str (rand-int 1000))})
                                (into [])))
             data*    (formula-of [data filter?]
                        (->> data
                             (filter (fn [{:keys [a]}]
                                       (if filter?
                                         (even? a)
                                         true)))
                             (into [])))]
         (div
          (buttons/a-button
           :latched? filter?
           :click #(swap! filter? not)
           "Filtered?")
          (buttons/a-button
           :click #(swap! data shuffle)
           "Shuffle")
          (buttons/a-button
           :click #(swap! data (fn [items]
                                 (sort-by :id items)))
           "Sort")
          (buttons/a-button
           :click #(swap! data
                          (fn [items]
                            (let [n (rand-int (count items))]
                              (with-let [i* (concat (take n items)
                                                 [{:id  (->> items
                                                             (map :id)
                                                             (reduce max 0)
                                                             inc)
                                                   :a (rand-int 1000)
                                                   :b (rand-int 1000)
                                                   :c (str (rand-int 1000))}]
                                                 (drop n items))]
                                (.log js/console "Inserting" n (pr-str i*))))))
           "Insert one")
          (buttons/a-button
           :click #(swap! data
                          (fn [items]
                            (if (empty? items)
                              items
                              (let [n (rand-int (count items))]
                                (concat (take n items) (drop (inc n) items))))))
           "Remove one")
          (grids/table-grid
           {:data            data*
            :key-fn          :id
            :row-attrs       (fn [id] {})
            :when-empty      "I am empty"
            :columns         {:a {:title     "A"
                                  :sort-key  :a
                                  :formatter #(-> % :a str cell= div)}
                              :b {:title     "B"
                                  :sort-key  :b
                                  :formatter #(-> % :b str cell= div)}
                              :c {:title     "C"
                                  :sort-key  :c
                                  :formatter #(-> % :c str cell= div)}}
            :fixed-columns   [:b]
            :movable-columns (cell [:a :c])
            :hidden-columns  (cell #{:c})})))
       #_(grids/rtable-grid
          {:data            (cell (into []
                                        (for [n (range 100)]
                                          {:id n
                                           :a  n
                                           :b  (- 100 n)
                                           :c  (str (rand-int 1000))}
                                          )) #_[{:id 1 :a 1 :b 2 :c "three"}
                                        {:id 2 :a 3 :b 1 :c "four"}
                                        {:id 3 :a 2 :b 4}])
           :key-fn          :id
           :row-attrs       (fn [id] {})
           :when-empty      "I am empty"
           :columns         {:a {:title     "A"
                                 :sort-key  :a
                                 :formatter #(-> % :a str)}
                             :b {:title     "B"
                                 :sort-key  :b
                                 :formatter #(-> % :b str)}
                             :c {:title     "C"
                                 :sort-key  :c
                                 :formatter #(-> % :c str)}}
           :fixed-columns   [:b]
           :movable-columns (cell [:a :c])
           :hidden-columns  (cell #{:c})})
       #_(hr)
       #_(grids/table-grid
          {:data            (cell (into []
                                        (for [n (range 100)]
                                          {:id n
                                           :a  n
                                           :b  (- 100 n)
                                           :c  (str (rand-int 1000))}
                                          )) #_[{:id 1 :a 1 :b 2 :c "three"}
                                        {:id 2 :a 3 :b 1 :c "four"}
                                        {:id 3 :a 2 :b 4}])
           :row-attrs       (fn [id] {})
           :when-empty      "I am empty"
           :columns         {:a {:title     "A"
                                 :sort-key  :a
                                 :formatter #(-> % :a str cell= div)}
                             :b {:title     "B"
                                 :sort-key  :b
                                 :formatter #(-> % :b str cell= div)}
                             :c {:title     "C"
                                 :sort-key  :c
                                 :formatter #(-> % :c str cell= div)}}
           :fixed-columns   [:b]
           :movable-columns (cell [:a :c])
           :hidden-columns  (cell #{:c})})))
    #_(hr)
    #_(with-let [parent (.createElement js/document "div")]
        (rum.core/mount
         (grids/RSimpleGrid
          (into []
                (for [n (range 100)]
                  {:id n
                   :a  n
                   :b  (- 100 n)
                   :c  (str (rand-int 1000))}
                  ))
          [:id :a :b :c])
         parent))
    #_(let [latched? (cell false)
            element  (div
                      :class "element"
                      :css {:background "green"
                            :color      "white"
                            :width      (px 100)
                            :height     (px 100)}
                      "Element")
            content  (div
                      :class "content"
                      :css {:background "yellow"
                            :color      "black"
                            :width      (px 200)
                            :height     (px 150)}
                      "Content")
            ;; element (div
            ;;          (div
            ;;           :toggle latched?
            ;;           :css {:background "white"
            ;;                 :border-color "black"
            ;;                 :border-width (px 1)}
            ;;           "This is some content"))
            ;; toggler (div
            ;;          (buttons/a-button
            ;;           :click #(swap! latched? not)
            ;;           :latched? latched?
            ;;           :css {:border-radius "50%"
            ;;                 :width (px 15)
            ;;                 :height (px 15)
            ;;                 :text-align "center"
            ;;                 :font-weight "bold"
            ;;                 :font-family "serif"
            ;;                 :line-height (px 12)}
            ;;           (div
            ;;            :css {:border-radius "50%"
            ;;                  :width (px 15)
            ;;                  :height (px 15)
            ;;                  :text-align "center"
            ;;                  :font-weight "bold"
            ;;                  :font-family "serif"
            ;;                  :line-height (px 12)
            ;;                  :color "white"
            ;;                  :background "blue"
            ;;                  :border-color "white"
            ;;                  :border-with (px 2)}
            ;;            "i")))
            ]
        (div
         :css {:position "relative"}
         element
         content))
    #_(grids/table-grid
       :data [{:foo  1
               :bar  2
               :baaz "a"
               :quux "hi"}
              {:foo  3
               :bar  4
               :baaz "b"
               :quux "there"}
              {:foo  10
               :bar  2034234
               :baaz "c"
               :quux "long words"}]
       :row-attrs (constantly {})
       :hidden-columns hidden-columns
       :fixed-columns (cell [])
       :movable-columns movable-columns
       :columns {:foo  {:title     "foo"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:foo item)))
                        :sort-key  :foo
                        :css       (fn [item rownum]
                                     (formula-of [item rownum]
                                       {:background-color (if (odd? rownum)
                                                            "purple"
                                                            "pink")}))}
                 :bar  {:title     "bar"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:bar item)))
                        :sort-key  :bar}
                 :baaz {:title     "baaz"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:baaz item)))
                        :sort-key  :baaz}
                 :quux {:title     "quux"
                        :formatter (fn [item]
                                     (formula-of [item]
                                       (:quux item)))
                        :sort-key  :quux}}))))
