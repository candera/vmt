(page "index.html"
  (:require [hoplon.svg :as svg]
            [goog.dom :as gdom]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [weathergen.canvas :as canvas]
            [weathergen.coordinates :as coords]
            [weathergen.database :as db]
            [weathergen.fmap :as fmap]
            [weathergen.help :as help]
            [weathergen.math :as math]
            [weathergen.model :as model]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [cljs.reader :as reader]
            [cljsjs.jquery-ui])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [weathergen.cljs.macros :refer [with-time formula-of]]))

;;; Constants

(def revision 6)

;;; Browser detection

(def agents (let [is-agent? (fn [agent]
                              (-> js/navigator
                                  .-userAgent
                                  (.indexOf agent)
                                  neg?
                                  not))
                  agent-props {:chrome  "Chrome"
                               :ie      "MSIE"
                               :firefox "Firefox"
                               :safari  "Safari"
                               :opera   "op"}]
              (zipmap (keys agent-props)
                      (map is-agent? (vals agent-props)))))

(cond
  (and (:safari agents)
       (not (:chrome agents)))
  (js/alert "WeatherGen does not work well in Safari, due to Safari's atrocious Javascript performance and some weird layout issues. Chrome and Firefox are the recommended/supported browsers.")

  (or (:firefox agents) (:chrome agents))
  (println "Chrome or Firefox detected")

  :else
  (js/alert "Browsers other than Chrome and Firefox are not currently supported by WeatherGen. Some features may not behave as expected. Use of Chrome/Firefox is recommended."))


;;; State

(defc weather-params {:temp-uniformity 0.7
                      :pressure        {:min 28.5 :max 31}
                      :cell-count      [59 59]
                      :feature-size    10
                      :categories      {:sunny     {:weight 20
                                                    :wind   {:min 0 :mean 7 :max 20}
                                                    :temp   {:min 20 :mean 22 :max 24}}
                                        :fair      {:weight 0.7
                                                    :wind   {:min 5 :mean 10 :max 30}
                                                    :temp   {:min 18 :mean 21 :max 23}}
                                        :poor      {:weight 5
                                                    :wind   {:min 10 :mean 18 :max 30}
                                                    :temp   {:min 15 :mean 18 :max 21}}
                                        :inclement {:weight 2
                                                    :wind   {:min 15 :mean 25 :max 60}
                                                    :temp   {:min 12 :mean 14 :max 16}}}
                      :turbulence      {:size 1 :power 250}
                      :origin          [1000 1000]
                      :evolution       3600
                      :time            {:offset 1234
                                        :current {:day 1 :hour 5 :minute 0}}
                      :wind-uniformity 0.7
                      :crossfade       0.1
                      :prevailing-wind {:heading 325}
                      :seed            1234
                      :wind-stability-areas [{:bounds {:x 16
                                                       :y 39
                                                       :width 6
                                                       :height 4}
                                              :wind {:speed 5
                                                     :heading 0}
                                              :index 0}]})

(defc movement-params {:step 60
                       :direction {:heading 135 :speed 30}})

;; TODO: Flip to portrait layout once the aspect ratio goes below a
;; certain point. Maybe dynamically.
(def initial-size (max 250 (- (.width (js/$ js/window)) 600)))

(defc display-params {:dimensions [initial-size initial-size]
                      :opacity    0.75
                      :display    :type
                      :map        :korea
                      :mouse-mode :select
                      :overlay    :wind})

(defc selected-cell nil)

(defc pending-wind-stability-area nil)

(defc current-tool :select)

(defc time-params
  {:displayed {:day 1 :hour 5 :minute 0}})

;;; Formulas

(defc= weather-data (with-time "Compute model"
                      (model/weather-grid weather-params)))

(defc= selected-cell-weather (get weather-data (:coordinates selected-cell)))

(defc= cell-count (:cell-count weather-params))

(defc= wind-stability-areas
  (->> weather-params
       :wind-stability-areas))

#_(defc= grid-data {:display-params display-params
                  :cell-count cell-count
                  :weather-data weather-data
                  :selected-cell selected-cell
                  :wind-stability-areas wind-stability-areas})

(defc= forecast (when selected-cell
                  (let [result (model/forecast
                                (:coordinates selected-cell)
                                weather-params
                                movement-params
                                (math/clamp 5 (/ 360 (:step movement-params)) 15))]
                    result)))

(defc= airbases (->> (db/airbases (:map display-params))
                     (map :name)
                     sort))

(defc= location-type
  (cond
    (-> selected-cell :location not-empty) :named
    (:coordinates selected-cell) :coordinates
    :else :none))

;;; Utility

(def log println)

(defn remove-nth
  [coll n]
  (vec (concat (take n coll) (drop (inc n) coll))))

(defn invert-map
  [m]
  (zipmap (vals m) (keys m)))

(def map-name->key
  {"Israel" :israel
   "Balkans" :balkans
   "Korea" :korea})

(def map-key->name
  (invert-map map-name->key))

(def map-image
  {:korea "images/kto.jpg"
   :balkans "images/balkans.png"
   :israel "images/ito.jpg"})

(defn map-image-id
  [map]
  (str "map-image-" (name map)))

(def display-name->key
  {"Weather Type" :type
   "Pressure" :pressure
   "Temperature" :temperature})

(def display-key->name
  (invert-map display-name->key))

(def overlay-name->key
  {"Wind" :wind
   "Pressure" :pressure
   "Temperature" :temperature
   "Weather Type" :type})

(def overlay-key->name
  (invert-map overlay-name->key))

(def type-name->key
  {"Sunny" :sunny
   "Fair" :fair
   "Poor" :poor
   "Inclement" :inclement})

(def type-key->name
  (invert-map type-name->key))

;;; Mutations

;; TODO: Put more of these here

(defn move
  "Advances the weather by `steps` steps"
  [steps]
  (dosync
   (let [{:keys [time]} (swap! weather-params
                               model/step
                               @movement-params
                               steps)]
     (swap! time-params
            assoc
            :displayed
            (:current time)))))

(defn jump-to-time
  "Adjust the time coordinate to match the displayed time."
  []
  (dosync
   (let [{:keys [time]} (swap! weather-params
                               model/jump-to-time
                               @movement-params
                               (:displayed @time-params))]
     (swap! time-params
            assoc
            :displayed
            (:current time)))))

(defn set-time
  "Adjust the time coordinate so that the current time is adjusted to
  match the displayed time without changing the location in weather
  space."
  []
  (swap! weather-params
         model/set-time
         (:displayed @time-params)))

(defn change-location
  [airbase]
  (if (empty? airbase)
    (reset! selected-cell nil)
    (reset! selected-cell {:location airbase
                           :coordinates (coords/airbase-coordinates
                                         @cell-count
                                         (:map @display-params)
                                         airbase)})))

(defn change-theater
  [theater]
  (dosync
   (swap! selected-cell
          #(if (= :named @location-type)
             nil
             %))
   (swap! display-params assoc :map theater)))

;;; Serialization

(defn save-data
  [blob filename]
  (let [a (gdom/createElement "a")
        _ (-> (gdom/getDocument) .-body (gdom/appendChild a))
        _ (gstyle/showElement a false)
        url (-> js/window .-URL (.createObjectURL blob))]
    (-> a .-href (set! url))
    (-> a .-download (set! filename))
    (.click a)
    (-> js/window .-URL (.revokeObjectURL url))))

(defn save-fmap
  [weather-params weather-data]
  (let [t (get-in weather-params [:time :current])
        [x-cells y-cells] (:cell-count weather-params)
        blob (fmap/get-blob weather-data
                            x-cells
                            y-cells)]
    (save-data blob (gstring/format "%d%02d%02d.fmap"
                                    (:day t)
                                    (:hour t)
                                    (:minute t)))))

(defn save-settings
  [_]
  (save-data (js/Blob. #js[(pr-str {:weather-params @weather-params
                                    :movement-params @movement-params
                                    :display-params @display-params
                                    :revision revision})]
                       #js{:type "text/plain"})
             "weathergen-settings.edn"))

(defn load-settings
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(let [data (-> %
                                      .-target
                                      .-result
                                      reader/read-string)]
                         (dosync
                          (let [{:keys [time]} (swap! weather-params merge (:weather-params data))]
                            (swap! display-params merge (:display-params data))
                            (swap! movement-params merge (:movement-params data))
                            (swap! time-params assoc :displayed (:current time)))))))
            (.readAsText reader file)))))))

;;; Help

(let [help-states (cell {})]
  (defelem help [{:keys []} contents]
    (let [id (str (gensym))
          content-id (str "content-" id)
          img-id (str "img-" id)]
      (div
       :class "help"
       (div
        :id content-id
        :fade-toggle (cell= (get help-states id))
        :class "content"
        :click #(swap! help-states assoc id false)
        contents)
       (div
        :id img-id
        :class "img"
        :click #(swap! help-states
                       (fn [hs]
                         (merge (zipmap (keys hs) (repeat false))
                                {id (not (get hs id))})))
        ;; TODO; Don't make the help go away if the place the mouse
        ;; has gone is the help content.
        ;; :mouseout (fn []
        ;;             (go (<! (async/timeout 1000))
        ;;                 (swap! help-states assoc id false)))
        "?")))))

(defn help-for
  [help-path]
  (help (or (get-in help/content help-path)
            (p "Help content has not yet been written for this feature."))))

;;; Grid interaction

(defn grid-click
  "Handle the mouse clicking on the canvas"
  [e canvas-id cell-count dimensions]
  (let [[width height] dimensions
        [nx ny] cell-count
        canvas (gdom/getElement canvas-id)
        r (.getBoundingClientRect canvas)
        x (-> e .-clientX (- (.-left r)) (/ width) (* nx) int)
        y (-> e .-clientY (- (.-top r)) (/ height) (* ny) int)]
    (reset! selected-cell {:location nil
                           :coordinates [x y]})))

;;; Grid rendering

(def weather-color
  {:sunny [255 255 255 0.25]
   :fair [0 255 0 1]
   :poor [255 255 0 1]
   :inclement [192 0 0 1]
   nil [255 0 0 1]})

(def pressure-map
  {28.5 [192 0 0 1]
   28.9 [192 0 0 1]
   29.3 [255 255 0 1]
   29.5 [0 255 0 1]
   29.9 [0 128 255 1]
   30.2 [255 255 255 1]
   31.0 [255 255 255 1]})

(defn gradient-color
  [color-map val]
  (let [[[low l] [high h]] (->> color-map
                                (into (sorted-map))
                                (partition 2 1)
                                (filter (fn [[[low l] [high h]]]
                                          (<= low val high)))
                                first)]
    (math/vector-interpolate l h val low high)))

(defn pressure-color
  [pressure]
  (let [[r g b a] (gradient-color pressure-map pressure)]
    [(long r) (long g) (long b) a]))

(def temp-map
  {0  [0 0 255 1]
   20 [0 255 0 1]
   40 [255 0 0 1]})

(defn temperature-color
  [temp]
  (let [[r g b a] (gradient-color temp-map temp)]
    [(long r) (long g) (long b) a]))

(defn fill-color
  [display w]
  ;;(println "fill-color" :w w :display display :alpha alpha)
  (case display
    :type (-> w :type weather-color)
    :pressure (-> w
                  :pressure
                  pressure-color)
    :temperature (-> w
                     :temperature
                     temperature-color)))

(defn clear-transform
  "Reset the current transform to the identity transform"
  [ctx]
  (.setTransform ctx 1 0 0 1 0 0))

;; TODO: There should be a way to set a base transform so that the
;; grid x and y map in a way that don't make us carry around the
;; dimensions everywhere. Maybe grid cells are 1x1, and the integer
;; x,y coordinates specify the center.
(defn set-transform
  "Sets the transform so that the grid cell at the specified x and y
  map to the unit square centered at the origin."
  [ctx x y cell-count canvas-dimensions]
  (let [[x-cells y-cells] cell-count
        [w h] canvas-dimensions
        width (/ w x-cells)
        height (/ h y-cells)]
    (doto ctx
      (clear-transform)
      ;; Some sort of weird bug where this doesn't work when x is 17
      (.translate (* (double (+ x 0.000001)) width) (* (double (+ y 0.00001)) height))
      (.scale (/ w x-cells) (/ h y-cells))
      (.translate 0.5 0.5))))

(defn set-fill
  [ctx r g b a]
  (-> ctx .-fillStyle (set!  (str "rgba("
                                  r ","
                                  g ","
                                  b ","
                                  a ")"))))

(defmulti prep-overlay (fn [ctx overlay] overlay))

(defmethod prep-overlay :default
  [_ _])

(defmethod prep-overlay :wind
  [ctx _]
  (-> ctx .-lineWidth (set! 0.07)))

(defn prep-text-overlay
  [ctx]
  (set-fill ctx 0 0 0 1)
  ;;(-> ctx .-lineStyle (set! "0.2"))
  (-> ctx .-lineWidth (set! "0.07"))
  (-> ctx .-font (set! "1px bold serif")))

(defmethod prep-overlay :temperature
  [ctx _]
  (prep-text-overlay ctx))

(defmethod prep-overlay :pressure
  [ctx _]
  (prep-text-overlay ctx))

(defmethod prep-overlay :coords
  [ctx _]
  (prep-text-overlay ctx))

(defmethod prep-overlay :type
  [ctx _]
  (prep-text-overlay ctx))

(defmulti stroke-overlay (fn [ctx overlay weather] overlay))

(defmethod stroke-overlay :default
  [_ _ _])

(defmethod stroke-overlay :wind
  [ctx overlay weather]
  (let [{:keys [speed heading]} (:wind weather)
        effective-speed (math/nearest speed 5)
        ticks (math/clamp 1 100 (int (/ effective-speed 5)))
        full-tails (int (/ ticks 2))
        half-tail? (odd? ticks)
        scale 1
        offset 0.1
        tail-step 0.18
        tail-slant 0.1
        tail-width (* 0.25 1.5)]
    (.scale ctx scale scale)
    (.translate ctx 0 offset)
    ;; Vector line
    (doto ctx
      (.rotate (math/deg->rad heading))
      (.moveTo 0 (- 0.5 tail-slant))
      (.lineTo 0 (+ -0.5 tail-slant)))

    ;; Full tails
    (dotimes [n full-tails]
      (.moveTo ctx 0 (+ (+ -0.5 tail-slant)
                        (* tail-step n)))
      (.lineTo ctx tail-width (+ -0.50 (* tail-step n))))

    ;; Half tails
    (when half-tail?
      (.moveTo ctx
               0
               (+ (+ -0.50 tail-slant)
                  (* tail-step full-tails)))
      (.lineTo ctx
               (* tail-width 0.5)
               (+ -0.50 (+ (* tail-step full-tails)
                           (* 0.5 tail-step)))))))

(defn stroke-text-overlay
  [ctx text]
  (.save ctx)
  ;; Firefox bug workaround - it seems to enforce a minimum text size
  (.scale ctx 0.42 0.42)
  (.fillText ctx
             text
             (-> text count (* -0.24))
             0.2)
  (.restore ctx))

(defmethod stroke-overlay :pressure
  [ctx overlay weather]
  (stroke-text-overlay ctx (-> weather :pressure (.toFixed 2))))

(defmethod stroke-overlay :temperature
  [ctx overlay weather]
  (stroke-text-overlay ctx (-> weather :temperature (.toFixed 1))))

(defmethod stroke-overlay :type
  [ctx overlay weather]
  (stroke-text-overlay ctx (-> weather :type {:sunny "S"
                                              :fair "F"
                                              :poor "P"
                                              :inclement "I"})))

(defmethod stroke-overlay :coords
  [ctx overlay weather]
  (stroke-text-overlay ctx (str (:x weather) "," (:y weather))))

(defn draw-map
  "Draws the map, unless the image is not ready. In that case, returns
  a channel that will close when it is."
  [ctx map [w h]]
  #_(when (map-image map)
    (let [img (gdom/getElement (map-image-id map))]
      (if (.-complete img)
        (do (.drawImage ctx
                        img
                        0 0
                        w h)
            nil)
        (let [ch (async/chan)]
          (-> img .-onload (set! (fn [_]
                                   (async/put! ch :done)
                                   (async/close! ch))))
          ch)))))

(defn draw-data
  "Draws the data layer"
  [ctx display opacity weather-data cell-count dimensions]
  (when (display-key->name display)
    (.save ctx)
    (doseq [[[x y] weather] weather-data
            :let [[r g b a] (fill-color display weather)]]
      (set-transform ctx x y cell-count dimensions)
      (set-fill ctx r g b (* a opacity))
      (.fillRect ctx -0.5 -0.5 1 1))
    (.restore ctx)))

(defn draw-overlay
  "Draws the overlay layer"
  [ctx overlay weather-data cell-count dimensions]
  (.save ctx)
  (prep-overlay ctx overlay)
  (.beginPath ctx)
  (doseq [[[x y] weather] weather-data
          :let [weather (assoc weather :x x :y y)]]
    (set-transform ctx x y cell-count dimensions)
    (stroke-overlay ctx overlay weather))
  (.stroke ctx)
  (.restore ctx))

(defn draw-selected-cell
  "Draws a border around the currently selected cell"
  [ctx [x y] cell-count dimensions]
  (when (and x y)
    (.save ctx)
    (set-transform ctx x y cell-count dimensions)
    (.setLineDash ctx #js [0.2 0.12])
    (-> ctx .-lineWidth (set! "0.15"))
    (-> ctx .-lineDashOffset (set! 2))
    (-> ctx .-fillStyle (set! "rgba(0,0,0,0.5)"))
    (.fillRect ctx -0.5 -0.5 1 1)
    (.strokeRect ctx -0.5 -0.5 1 1)
    (.restore ctx)))

(defn draw-wind-stability
  "Draws a border around the wind stability areas"
  [ctx areas cell-count dimensions]
  (doseq [{:keys [x y width height]} (map :bounds areas)]
    (.save ctx)
    (set-transform ctx x y cell-count dimensions)
    (.setLineDash ctx #js [0.5 0.5])
    (-> ctx .-lineWidth (set! "0.2"))
    (-> ctx .-lineDashOffset (set! 0))
    (.strokeRect ctx -0.5 -0.5 width height)
    (-> ctx .-strokeStyle (set! "white"))
    (-> ctx .-lineDashOffset (set! 0.5))
    (.strokeRect ctx -0.5 -0.5 width height)
    (.restore ctx)))

(defn draw-grid
  [{:keys [display-params cell-count wind-stability-areas weather-data selected-cell] :as data}]
  (with-time "draw-grid"
    (let [canvas (gdom/getElement "weather-grid")
          {:keys [map
                  opacity
                  dimensions
                  display
                  overlay]} display-params
          [w h]  dimensions]
      (if-not (= w (.-width canvas))
        (let [ch (async/chan)]
          #_(println "canvas is not done loading" :dimensions dimensions
                     :width (.-width canvas)
                     :height (.-height canvas))
          (go-loop [n 200]
            (<! (async/timeout 10))
            (when (pos? n)
              (if (= w (.-width canvas))
                (draw-grid data)
                (do
                  (println "Still waiting for canvas" :n n)
                  (recur (dec n)))))))
        (let [ctx               (.getContext canvas "2d")
              [x-cells y-cells] cell-count
              cell-width        (/ w x-cells)
              cell-height       (/ h y-cells)]
          #_(println "Canvas is correct size" :dimensions dimensions
                     :width (.-width canvas)
                     :height (.-height canvas))
          (clear-transform ctx)
          (.clearRect ctx 0 0 w h)

          ;; Draw the map if it's ready
          (if-let [ch (draw-map ctx map dimensions)]
            (go
              (<! ch)
              (draw-grid data))

            (do
              (draw-data ctx display opacity weather-data cell-count dimensions)
              (draw-overlay ctx overlay weather-data cell-count dimensions)

              ;; Draw bounding boxes
              #_(doseq [x (range x-cells)
                        y (range y-cells)]
                  (set-transform ctx x y cell-count dimensions)
                  (.strokeRect ctx -0.5 -0.5 1 1))

              (draw-selected-cell ctx (:coordinates selected-cell) cell-count dimensions)
              (draw-wind-stability ctx wind-stability-areas cell-count dimensions))))))))

(def max-wind-vector-speed 50)

(defn wind-vector-id
  [speed]
  (str "wind-vector-" (math/clamp 5 max-wind-vector-speed (math/nearest speed 5))))

(defn update-wind-layer
  [weather-data display-params]
  (with-time "update-wind-layer"
    (doseq [[[x y] weather] weather-data
            :let [{:keys [speed heading]} (:wind weather)
                  cell (gdom/getElement (str "grid-wind-cell-" x "-" y))]]
      (.setAttribute cell
                     #_"http://www.w3.org/2000/svg"
                     "transform"
                     (str "rotate(" (long heading) ")"))
      (.setAttributeNS cell
                       "http://www.w3.org/1999/xlink"
                       "href"
                       (str "#" (wind-vector-id speed))))))

(defmulti overlay-text
  (fn [weather overlay] overlay))

(defmethod overlay-text :default
  [_ _]
  "")

(defmethod overlay-text :pressure
  [weather _]
  (-> weather :pressure (.toFixed 2)))

(defmethod overlay-text :temperature
  [weather overlay]
  (-> weather :temperature (.toFixed 1)))

(defmethod overlay-text :type
  [weather overlay]
  (-> weather :type {:sunny "S"
                     :fair "F"
                     :poor "P"
                     :inclement "I"}))

(defmethod overlay-text :coords
  [weather overlay]
  (str (:x weather) "," (:y weather)))

(defn update-text-layer
  [weather-data display-params]
  (with-time "update-text-layer"
    (doseq [[[x y] weather] weather-data
            :let [text (overlay-text weather (:overlay display-params))
                  cell (gdom/getElement (str "grid-text-cell-" x "-" y))]]
      (-> cell .-innerHTML (set! text)))))

(defn update-overlay
  [weather-data display-params]
  (with-time "update-overlay"
   (condp contains? (:overlay display-params)
     #{:wind}
     (update-wind-layer weather-data display-params)

     #{:type :pressure :temperature}
     (update-text-layer weather-data display-params)
     nil)))

(defn update-primary-layer
  [weather-data display-params]
  (with-time "update-primary-layer"
    (doseq [[[x y] weather] weather-data
            :let [[r g b a] (fill-color (:display display-params) weather)
                  cell (gdom/getElement (str "grid-primary-cell-" x "-" y))]]
      (.setAttribute cell "fill" (str "rgba("
                                      r ","
                                      g ","
                                      b ","
                                      a ")")))))

(defn update-grid-data
  [weather-data display-params]
  (with-time "update-grid-data"
    (do
      (update-primary-layer weather-data display-params)
      (update-overlay weather-data display-params))))

(defn update-grid
  [weather-data display-params]
  (with-time "update-grid"
    (update-grid-data weather-data display-params)))

(def wind-vector-defs
  (svg/defs
    (for [speed (range 5 (inc max-wind-vector-speed) 5)]
      (let [ticks (math/clamp 1 100 (int (/ speed 5)))
            full-tails (int (/ ticks 2))
            half-tail? (odd? ticks)
            scale 1
            offset 0.1
            tail-step 0.18
            tail-slant 0.1
            tail-width (* 0.25 1.5)]
        (svg/g
         :id (wind-vector-id speed)
         ;; Vector line
         #_(doto ctx
             (.rotate (math/deg->rad heading))
             (.moveTo 0 (- 0.5 tail-slant))
             (.lineTo 0 (+ -0.5 tail-slant)))
         (svg/line
          :attr {:class "wind-vector"}
          :x1 0
          :x2 0
          :y1 (- 0.5 tail-slant)
          :y2 (+ -0.5 tail-slant))

         ;; Full tails
         #_(dotimes [n full-tails]
             (.moveTo ctx 0 (+ (+ -0.5 tail-slant)
                               (* tail-step n)))
             (.lineTo ctx tail-width (+ -0.50 (* tail-step n))))
         (svg/g
          :attr {:class "wind-vector full-tail"}
          (for [n (range full-tails)]
            (svg/line :x1 0
                      :y1 (+ (+ -0.5 tail-slant)
                             (* tail-step n))
                      :x2 tail-width
                      :y2 (+ -0.50 (* tail-step n)))))

         ;; Half tails
         #_(when half-tail?
             (.moveTo ctx
                      0
                      (+ (+ -0.50 tail-slant)
                         (* tail-step full-tails)))
             (.lineTo ctx
                      (* tail-width 0.5)
                      (+ -0.50 (+ (* tail-step full-tails)
                                  (* 0.5 tail-step)))))
         (when half-tail?
           (svg/line
            :attr {:class "wind-vector half-tail"}
            :x1 0
            :y1 (+ (+ -0.50 tail-slant)
                   (* tail-step full-tails))
            :x2 (* tail-width 0.5)
            :y2 (+ -0.50 (+ (* tail-step full-tails)
                            (* 0.5 tail-step))))))))))

(defelem grid
  [{:keys [display-params
           selected-cell
           weather-data
           wind-stability-areas
           nx
           ny]
    :as attrs}]
  (let [primary-layer (svg/g
                       :id "primary-layer"
                       :css (cell= {:opacity (-> display-params :opacity)}))
        wind-overlay (svg/g
                      :id "wind-overlay"
                      :toggle (cell= (-> display-params
                                         :overlay
                                         (= :wind))))
        text-overlay (svg/g
                      :id "text-overlay"
                      #_:attr #_{:class (-> data
                                            :display-params
                                            :overlay)}
                      :toggle (cell= (-> display-params
                                         :overlay
                                         #{:pressure :temperature :type})))
        wind-stability-overlay (formula-of
                                [wind-stability-areas]
                                (svg/g
                                 :id "wind-stability-overlay"
                                 (for [area wind-stability-areas]
                                   (let [{:keys [x y width height]} (:bounds area)]
                                     [(svg/rect
                                       :attr {:class "wind-stability-area"}
                                       :x x
                                       :y y
                                       :width width
                                       :height height)
                                      (svg/rect
                                       :attr {:class "wind-stability-area alternate"}
                                       :x x
                                       :y y
                                       :width width
                                       :height height)]))))
        selected-cell-overlay (formula-of
                               [selected-cell]
                               (let [[x y] (:coordinates selected-cell)]
                                 (if (and x y)
                                   (svg/rect
                                    :id "selected-cell-overlay"
                                    :x x
                                    :y y
                                    :width 1
                                    :height 1)
                                   [])))]
    (with-let [elem (svg/svg
                     (-> attrs
                         (dissoc :display-params :selected-cell :weather-data)
                         (assoc :viewBox (gstring/format "0 0 %d %d" nx ny)
                                :width (cell= (-> display-params :dimensions first))
                                :height (cell= (-> display-params :dimensions second))
                                :attr {"xmlns:xlink" "http://www.w3.org/1999/xlink"
                                       "xmlns" "http://www.w3.org/2000/svg"}))
                     wind-vector-defs
                     ;; TODO: Not working in Firefox/Safari because
                     ;; the image tag doesn't render as
                     ;; self-closing. Not sure how to convince
                     ;; Hoplon to change that.
                     (svg/image
                      :id "map-image"
                      :toggle (cell= (-> display-params :map #{:none nil} not))
                      :xlink-href (cell= (or (-> display-params :map map-image) ""))
                      :x 0
                      :y 0
                      :width nx
                      :height ny)
                     primary-layer
                     wind-overlay
                     text-overlay
                     wind-stability-overlay
                     selected-cell-overlay)]
      ;; TODO: We're capturing the value of the number of cells, but it
      ;; never changes. One of these days I should probably factor this
      ;; out. Either that or just react to changes in the number of
      ;; cells by re-inserting the child rects.
      (with-init!
        (with-time "Initial create"
          (do
            ;; Primary layer
            (let [frag (.createDocumentFragment js/document)]
              (doseq [x (range nx)
                      y (range ny)]
                (let [r (doto (.createElementNS
                               js/document
                               "http://www.w3.org/2000/svg"
                               "rect")
                          (.setAttribute "id" (str "grid-primary-cell-" x "-" y))
                          (.setAttribute "x" (str x))
                          (.setAttribute "y" (str y))
                          (.setAttribute "width" "1")
                          (.setAttribute "height" "1")
                          (-> .-onclick
                              (set! #(reset! selected-cell {:location nil
                                                            :coordinates [x y]}))))]
                  (gdom/appendChild frag r)))
              (gdom/appendChild primary-layer frag))
            ;; Wind vector layer
            (let [frag (.createDocumentFragment js/document)]
              (doseq [x (range nx)
                      y (range ny)]
                (let [g (doto (.createElementNS
                               js/document
                               "http://www.w3.org/2000/svg"
                               "g")
                          (.setAttribute "transform"
                                         #_"http://www.w3.org/2000/svg"
                                         (gstring/format "translate(%f, %f)"
                                                         (+ x 0.5)
                                                         (+ y 0.5))))
                      r (doto (.createElementNS
                               js/document
                               "http://www.w3.org/2000/svg"
                               "use")
                          (.setAttribute "id" (str "grid-wind-cell-" x "-" y)))]
                  (gdom/appendChild g r)
                  (gdom/appendChild frag g)))
              (gdom/appendChild wind-overlay frag))
            ;; Text overlay layer
            (let [frag (.createDocumentFragment js/document)
                  scale 0.02]
              (doseq [x (range nx)
                      y (range ny)]
                (let [t (doto (.createElementNS
                               js/document
                               "http://www.w3.org/2000/svg"
                               "text")
                          (.setAttribute "transform"
                                         ;; TODO: figure out how to center these stupid things
                                         (gstring/format "scale(%f) translate(%f, %f)"
                                                         scale
                                                         (/ (+ x 0.1) scale)
                                                         (/ (+ y 0.9) scale)))
                          (.setAttribute "id" (str "grid-text-cell-" x "-" y)))]
                  (gdom/appendChild frag t)))
              (gdom/appendChild text-overlay frag))))
        (let [display-params* (formula-of
                               [display-params]
                               (dissoc display-params :dimensions :opacity :map))]
          (formula-of
           [weather-data display-params*]
           (update-grid weather-data display-params*)))))))


;;; User Interface

(def ESCAPE_KEY 27)
(def ENTER_KEY 13)

(defelem control-section
  [attributes children]
  (let [visible (cell true)
        change-visibility #(swap! visible not)]
    (fieldset
     :class "controls"
     attributes
     (legend
      (div
       :click change-visibility
       :class (formula-of [visible]
                          {:toggle true
                           :visible visible})
       "")
      (span
       :click change-visibility
       (:title attributes))
      (if-let [h (:help-for attributes)]
        (help-for h)
        []))
     (div
      :class "control-container"
      :toggle visible
      :fade-toggle visible
      children))))

(defn two-column
  [left right]
  (div :class "two-column"
       (div :class "left-column" left)
       (div :class "right-column" right)))

(defn edit-field
  ([c path] (edit-field c path {}))
  ([c path opts]
   ;; TODO: Add conversion to/from string and validation
   (let [{:keys [change-fn]} opts]
    (input :type "text"
           :value (cell= (get-in c path))
           :change (if change-fn
                     #(change-fn (js/Number @%))
                     #(swap! c assoc-in path (js/Number @%)))))))

(defn time-entry
  [c path]
  ;; TODO: Make fancier
  (table
   :class "time-params"
   (thead
    (tr (map #(td :class "time-entry-label" %) ["Day" "Hour" "Minute"])))
   (tbody
    (tr (map #(td (edit-field c (conj path %))) [:day :hour :minute])))))

(defn button-bar
  []
  (div :class "button-bar"
       ;; Unfortunately, the way that Hoplon changes elements means
       ;; that the canvas resizes asynchronously, which screws up
       ;; redrawing. TODO: Fix this
       (button :id "enlarge-grid"
               :click #(swap! display-params
                              update
                              :dimensions
                              (fn [[x y]]
                                [(+ x 50) (+ y 50)]))
               :title "Enlarge grid"
               (img :src "images/bigger.png"))
       (button :id "shrink-grid"
               :click #(swap! display-params
                              update
                              :dimensions
                              (fn [[x y]]
                                [(- x 50) (- y 50)]))
               :title "Shrink grid"
               (img :src "images/smaller.png"))
       ;; TODO: Not quite there yet.
       #_(for [tool [:select :wind-stability]
             :let [id (str "tool-" (name tool))]]
         [(input
            :class (str "exclusive-button tool " (name tool))
            :type "radio"
            :name "tool"
            :id id
            :checked (cell= (= tool current-tool))
            :change #(do (println "Changed tool to " tool)
                         (reset! current-tool tool)))
          (label :for id
                 :css {:background-image (str "url('images/tool-" (name tool) ".png')")})
])))

#_(defn weather-grid
  []
  (cell-let [[width height] dimensions
             {:keys [map]}  display-params
             [nx ny] cell-count]
    (div :id "weather-grid-stack"
         :width (cell= width)
         :height (cell= height)
         (for [[k v] map-image]
           (img :id (map-image-id k)
                :width (cell= width)
                :height (cell= height)
                :style (cell= (if (= k map)
                                ""
                                "display: none"))
                :src v))
         (img :id "blank-map"
              :width (cell= width)
              :height (cell= height)
              :src "images/blank.png")
         (canvas :id "weather-grid"
                 :css (cell=
                       {:cursor  (case current-tool
                                   :select "pointer"
                                   :wind-stability "crosshair")})
                 :width (cell= width)
                 :height (cell= height)
                 :click #(grid-click % "weather-grid" @cell-count @dimensions)))))

(defn display-controls
  []
  (let [select-row (fn [{:keys [label k key->name name->key change]} help-path]
                     (tr (td label)
                         (td (select
                              :change (if change
                                        #(change (name->key @%))
                                        #(swap! display-params assoc k (name->key @%)))
                              (for [name (conj (keys name->key) "None")]
                                (option
                                 :value name
                                 :selected (cell= (-> display-params
                                                      k
                                                      key->name
                                                      (= name)))
                                 name))))
                         (td (help-for help-path))))]
    (control-section
     :title "Display controls"
     (div
      :class "display-controls"
      (table
       (tbody
        (select-row {:label "Map"
                     :k :map
                     :key->name map-key->name
                     :name->key map-name->key
                     :change change-theater}
                    [:display-controls :map])
        (select-row {:label "Display"
                     :k :display
                     :key->name display-key->name
                     :name->key display-name->key}
                    [:display-controls :display])
        (select-row {:label "Overlay"
                     :k :overlay
                     :key->name overlay-key->name
                     :name->key overlay-name->key}
                    [:display-controls :overlay])
        (tr (td "Opacity:")
            (td (input {:type "range"
                        :min 0
                        :max 100
                        :value (cell= (-> display-params
                                          :opacity
                                          (* 100)
                                          long))
                        :change #(swap! display-params
                                        assoc
                                        :opacity
                                        (/ @% 100.0))}))
            (td (help-for [:display-controls :opacity])))))))))

(defn weather-parameters
  []
  (control-section
   :title "Weather parameters"
   (table
    :id "general-params"
    (tbody
     (for [[label selector extra]
           [["Seed"             [:seed] (button
                                         :click #(swap! weather-params
                                                        assoc
                                                        :seed
                                                        (+ (rand-int 5000) 100))
                                         "Random")]
            ["Crossfade"        [:crossfade]]
            ["Zoom"             [:feature-size]]
            ["Max pressure"     [:pressure :max]]
            ["Min pressure"     [:pressure :min]]
            ["Prevailing wind"  [:prevailing-wind :heading]]
            ["Wind uniformity"  [:wind-uniformity]]
            ["Temp uniformity"  [:temp-uniformity]]
            ["Warp strength"    [:turbulence :power]]]]
       (tr (td label)
           (td (edit-field weather-params selector)
               (or extra []))
           (td (help-for (into [:weather-params] selector)))))))))

(let [indexed-wind-stability-areas (->> weather-params
                                        :wind-stability-areas
                                        (map-indexed vector)
                                        cell=)]
  (defn wind-stability-parameters
    []
    (control-section
     :title "Wind stability regions"
     :help-for [:wind-stability-areas]
     (loop-tpl :bindings [[index area] indexed-wind-stability-areas]
       (div
        :class "wind-stability-params"
        (table
         (tbody
          (tr (td "NW corner")
              (td (edit-field weather-params [:wind-stability-areas @index :bounds :x]))
              (td (edit-field weather-params [:wind-stability-areas @index :bounds :y])))
          (tr (td "Width/height")
              (td (edit-field weather-params [:wind-stability-areas @index :bounds :width]))
              (td (edit-field weather-params [:wind-stability-areas @index :bounds :height])))
          (tr (td "Wind spd/hdg")
              (td (edit-field weather-params [:wind-stability-areas @index :wind :speed]))
              (td (edit-field weather-params [:wind-stability-areas @index :wind :heading])))))
        (button
         :click #(swap! weather-params
                        update
                        :wind-stability-areas
                        (fn [areas]
                          (remove-nth areas @index)))
         "Remove")
        (hr)))
     (button
      :click #(swap! weather-params
                     update
                     :wind-stability-areas
                     (fn [areas]
                       (conj areas
                             {:bounds {:x 0 :y 0 :width 10 :height 10}
                              :wind {:heading 45
                                     :speed 5}
                              :index (count areas)})))
      "Add New"))))

(defn weather-type-configuration
  []
  (control-section
   :title "Weather type configuration"
   (table
    :id "category-params"
    (thead
     (tr (td "")
         (td "")
         (td :colspan 3 "Wind" (help-for [:weather-type-config :wind]))
         (td :colspan 3 "Temperature" (help-for [:weather-type-config :temp])))
     (tr (map #(apply td %)
              [""
               [:class "weight" "Weight" (help-for [:weather-type-config :weight])]
               ["Min"] ["Mean"] ["Max"]
               ["Min"] ["Mean"] ["Max"]])))
    (tbody
     (for [category [:sunny :fair :poor :inclement]]
       (tr (td
            :class (str "weather-type " (name category))
            :css {"background-color" (let [[r g b] (weather-color category)]
                                       (str "rgb(" r "," g "," b ")"))}
            (type-key->name category))
           (td
            (div :class "edit-field"
                 (edit-field weather-params [:categories category :weight])))
           (for [param [:wind :temp]
                 metric [:min :mean :max]]
             (td :class (str (name param) " " (name metric))
                 (div :class "edit-field"
                      (edit-field weather-params [:categories category param metric]))))))))))

(defn step-controls
  []
  (control-section
   :id "time-location-params"
   :title "Time/location controls"
   (table
    (tbody
     (tr (map td ["X Offset"
                  (edit-field weather-params [:origin 0])
                  (help-for [:weather-params :origin :x])]))
     (tr (map td ["Y Offset"
                  (edit-field weather-params [:origin 1])
                  (help-for [:weather-params :origin :y])]))
     (tr (map td ["T Offset"
                  (edit-field weather-params [:time :offset])
                  (help-for [:weather-params :time :offset])]))
     ;; (tr (map td ["Start Time" (time-entry weather-params [:time :start])]))
     (for [[c label path help]
           [[movement-params "Weather heading" [:direction :heading] :movement-params]
            [movement-params "Weather speed"   [:direction :speed]   :movement-params]
            [weather-params  "Evolution (min)" [:evolution]          :weather-params]]]
       (tr (map td [label
                    (edit-field c path)
                    (help-for (into [help] path))])))
     (tr (map td [["Time" (help-for [:displayed-time])]
                  (time-entry time-params [:displayed])
                  (button
                   :click jump-to-time
                   "Jump to")
                  (button
                   :click set-time
                   "Set to")]))
     (tr (map td ["Step interval"
                  (edit-field movement-params [:step])
                  (help-for [:step])]))))
   (button :title "Step back in time"
           :click #(move -1)
           "<< Step Back")
   (button :title "Step forward in time"
           :click #(move 1)
           "Step Forward >>")))

(defn serialization-controls
  []
  (control-section
   :id "load-save-controls"
   :title "Load/save"
   (div
    :class "button-container"
    (cell=
     (let [t (get-in weather-params [:time :current])
           [x-cells y-cells] (:cell-count weather-params)
           blob (fmap/get-blob weather-data
                               x-cells
                               y-cells)
           url (-> js/window .-URL (.createObjectURL blob))
           download (gstring/format "%d%02d%02d.fmap"
                                    (:day t)
                                    (:hour t)
                                    (:minute t))]
       (a :href url
          :download download
          :click #(move 1)
          :class "button"
          "Save Current as FMAP")))
    "(Steps forward in time)")
   (div
    :class "button-container"
    (cell=
     (let [blob (js/Blob. (clj->js [(pr-str {:weather-params weather-params
                                             :movement-params movement-params
                                             :display-params display-params
                                             :revision revision})])
                          #js{:type "text/plain"})
           url (-> js/window .-URL (.createObjectURL blob))]
       (a :href url
          :download "weathergen-settings.edn"
          :class "button"
          "Save Settings"))))
   (div
    :class "button-container"
    (button :class "button" :click load-settings "Load Settings"))))

(defn forecast-display
  []
  (control-section
   :title "Forecast"
   :help-for [:forecast]
   (div :id "forecast"
        (cell=
         (let [[x y] (:coordinates selected-cell)]
           (div
            (label :for "locations"
                   "Forecast for:")
            (select
               :id "locations"
               :change #(change-location @%)
               (option :selected (not= :named location-type)
                       :value ""
                       (case location-type
                         :coordinates (str "Cell " x "," y)
                         :named ""
                         :none "None selected"))
               (for [ab airbases]
                 (option :value ab
                         :selected (= ab (:location selected-cell))
                         ab)))
            (table
             (thead
              (tr (td "Day/Time")
                  (td "Weather Type")
                  (td "Pressure")
                  (td "Temperature")
                  (td "Wind Speed")
                  (td "Wind Heading")))
             (tbody
              (if-not forecast
                (tr (td :colspan 6
                        "No location is selected. Choose a location from the list, or click on the weather map to select one."))
                (for [[time weather] forecast]
                  (tr (td (gstring/format "%02d/%02d%02d"
                                          (:day time) (:hour time) (:minute time)))
                      (td (-> weather :type type-key->name))
                      (td (-> weather :pressure (.toFixed 2)))
                      (td (-> weather :temperature (.toFixed 1)))
                      (td (-> weather :wind :speed (.toFixed 0)))
                      (td (-> weather :wind :heading (.toFixed 0))))))))))))))

(defn debug-info
  []
  #_(div "Debug info"))

(defmethod do! :viewBox
  [elem _ value]
  (if (= false value)
    (.removeAttribute elem "viewBox")
    (.setAttribute elem "viewBox" value)))

(defmethod do! :xlink-href
  [elem _ value]
  (if (= false value)
    (.removeAttributeNS elem "http://www.w3.org/1999/xlink" "href")
    (do
      (log "Setting xlink attr")
      (.setAttributeNS elem "http://www.w3.org/1999/xlink" "href" value))))

(defmethod do! :preserveAspectRatio
  [elem _ value]
  (if (= false value)
    (.removeAttribute elem "preserveAspectRatio")
    (.setAttribute elem "preserveAspectRatio" value)))

(defn test-region
  []
  (let [n 59
        m (into {}
                (for [x (range n)
                      y (range n)]
                  [[x y] (cell (rand-int 4))]))]
    (with-time "test initial render"
      [(svg/svg
        :id "test"
        :viewBox (gstring/format "0 0 %d %d" n n)
        :width 600
        :height 600
        ;; :css {"display" "none"}
        #_(for [[[x y] c] m]
            (svg/rect
             :attr (formula-of [c] {:class (str "test" c)})
             :x x
             :y y
             :width 1
             :height 1)))
       (button
        :click (fn []
                 (.requestAnimationFrame
                  js/window
                  #(with-time "randomize"
                     (doseq [x (range n)
                             y (range n)]
                       (-> (str "cell-" x "-" y)
                           gdom/getElement
                           (.setAttribute "class" (str "test" (rand-int 4))))))))
        "Randomize")])))

(html
 (head
  (title "WeatherGen")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css"))
 (body
  (div
   :id "app"
   (div :id "titlebar"
        (div :id "words"
             (span :id "title"
                   "WeatherGen")
             (span :id "byline"
                   "by"
                   (a :href "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
                      :target "_blank"
                      "Tyrant"))
             (span :id "helpstring"
                   "Help? Bug? Feature request? Click"
                   (a :href "help.html"
                      :target "_blank"
                      "here")
                   "."))
        (a :href "http://firstfighterwing.com"
           :target "_blank"
           (img :id "winglogo"
                :src "images/1stVFW_Insignia-64.png")))
   (div :class "two-column"
        (div :class "left-column"
             (button-bar)
             (grid :display-params display-params
                   :weather-data weather-data
                   :selected-cell selected-cell
                   :wind-stability-areas wind-stability-areas
                   ;; TODO: Make these reactive, although they never
                   ;; change, so maybe not
                   :nx (first (:cell-count @weather-params))
                   :ny (second (:cell-count @weather-params)))
             #_(weather-grid))
        (div :class "right-column"
             (display-controls)
             (weather-parameters)
             (weather-type-configuration)
             (wind-stability-parameters)
             (step-controls)
             (serialization-controls)
             (forecast-display)))
   (debug-info))))

;;; Triggers

#_(add-watch grid-data
           :redraw-triggers
           (fn [k r o n]
             #_(draw-grid n)
             #_(update-grid o n)))

;;; Initialization

#_(draw-grid @grid-data)

;;(-> js/document js/jQuery .tooltip)
